var examples = {"CRM-Test-Data.eve":"# App Analytics\n\nThe `@view` database contains a number of handy canned visualizations that we can use. If they aren't inserted explicitly into the document, they'll attach themselves under the action that created them. We'll use a few of these views to keep track of our new application's pulse.\n\n\n### Total number of users\n\n```\nsearch\n  users = count[given: [#user]]\n\nbind @view\n  [#value | value: users]\n```\n\n### Average messages per conversations\n\n```\nsearch\n  threads = [#thread messages]\n  msgs-per-thread = count[given: messages] / count[given: threads]\n\nbind @view\n  [#value | value: msgs-per-thread]\n```\n\n### Conversations per hour\n\n```\nsearch\n  threads = [#thread time: [hour]]\n  c = count[given: threads per: hour]\n\nbind @view\n  [#value | value: \"{{hour}} -> {{c}}\"]\n\nbind @view\n  [#bar-graph | bar: [label: hour, height: c, sort: hour]]\n```\n\n### Messages per second\n\nCount all the messages that occurred in the last second and add them to a historical graph.\n\n```\nsearch\n  [#time timestamp]\n  message-count = if messages = [#message time > timestamp - 1000]\n                     message-count = count[given: messages]\n                  then message-count\n                  else 0\n\nbind @view\n  [#value | value: message-count]\n  [#history #messages-per-second values: [timestamp | value: message-count]]\n```\n\n# Mock data generation\n\n### Starting data\n\nFirst, create a bunch of random users and conversations.\n\n```\nsearch\n  r = range[from: 1 to: 100]\n  hour = round[value: gaussian[seed: r, Ïƒ: 3, Î¼: 12]]\n  hour' = if hour > 23 then 23\n          else if hour < 0 then 0\n          else hour\n\ncommit\n  [#thread #test-data r time: [hour]]\n  [#user #test-data r]\n```\n\nNext, prepopulate the threads with a set of initial messages.\n\n```\nsearch\n  threads = [#thread not(messages)]\n  [#time timestamp]\n  r = gaussian[seed: threads, Ïƒ: 1, Î¼: 6]\n  i = range[from: 1, to: r]\n\ncommit\n  threads.messages += [#message i]\n```\n\n### Live data\n\nEvery few seconds, add a random number of messages to a thread. All the math here is just fudge to make the pattern of messages more interesting.\n\n```\nsearch\n  [#time minutes seconds timestamp frames]\n  mod[value: seconds, by: floor[value: random[seed: minutes * seconds] * 5 + 5]] = 0\n  thread = [#thread r: floor[value: random[seed: frames] * 100]]\n  frames' = frames / 7\n  r = gaussian[seed: timestamp, Ïƒ: frames', Î¼: frames']\n  r' = if r < 0 then 0 else r\n  i = range[from: 0, to: r']\n\ncommit\n  thread.messages += [#message i: \"{{timestamp}}:{{i}}\" time: timestamp]\n```\n\nEvery few seconds, add a random number of users\n\n```\nsearch\n  t = [#time seconds]\n  min = 1\n  max = 10\n  r = random[seed: t.timestamp] * (max - min) + min\n  i = range[from: 1 to: r]\n  mod[value: seconds, by: floor[value: random[seed: seconds] * 8 + 5]] = 0\n\ncommit\n  [#user #test-data i: \"{{t.timestamp}}:{{i}}\"]\n```\n","CRM.eve":"# Contact Application\n\nThis application demonstrates some basic patterns you might want to use in a mobile application or website. These concepts include:\n\n- application architecture\n- navigating between pages\n- displaying lists of information\n- joining and filtering data\n- reusing interface components\n- responding to events\n\n## The App Record\n\n`#app` stores some useful state for the application, including the current user, the current page, and the current contact.\n\n```\ncommit\n  [#app]\n```\n\nSet some initial state on `#app` and mark it as `#init`. This block sets the start time of the app, so `#time` is brought into the search. Since we only want this to happen once, we search for `#app` that is not `#init`. Then, we mark the `#app` as `#init` to prevent the block from firing again due to a time update.\n\n```\nsearch\n  app = [#app]\n  [#time day month year hours minutes seconds ampm]\n  not(app = [#init])\n  //user = [#user name: \"Corey Montella\"]\n  user = [#user name: \"Eric Hoffman\"]\n\ncommit\n  app <- [#init user\n          page: [#about contact: user]\n          start-time: [#start-time day month year hours minutes seconds ampm]]\n```\n\n### Main App\n\nThe main application is a shell for all other pages in the app. This component draws the main interface, navigation buttons, and provides a \"content\" div into which other pages are injected.\n\n```\nsearch\n  app = [#app user]\n  [#time time-string]\n  // Handle the case when the user has no threads\n  threads = if app.unread then app.unread\n            else 0\n  // If the user is looking at a contact, display that contact's avatar and info. Otherwise, display the user's own avatar.\n  current-contact = if app.contact then app.contact\n                    else user\n\nbind @browser\n  [#link rel: \"stylesheet\" href: \"examples/css/crm.css\"]\n  [#div #container class: \"container\" children:\n    [#div class: \"scroll\" children:\n      [#div class: \"banner\"]\n      [#div class: \"bio-info\" children:\n        [#div class: \"avatar-container\" children:\n          [#img class: \"avatar\", src: current-contact.avatarURL]]\n        [#div class: \"name2\" text: \"{{current-contact.name}}\"]\n        [#div class: \"info\" text: \"{{current-contact.title}}\"]\n        [#div class: \"info\" text: \"{{time-string}}, {{current-contact.location}}\"]]\n      [#div #content class: \"content\"]]\n    [#div class: \"navigation\" children:\n      [#div #about #nav class: \"nav-button middle\", children:\n        [#div class: \"icon ion-person\"]\n        [#div class: \"label\" text: \"profile\"]]\n      [#div #threads #nav class: \"nav-button middle\", children:\n        [#div class: \"icon ion-chatboxes\"]\n        [#div class: \"bubble\" text: threads]\n        [#div class: \"label\" text: \"messages\"]]\n      [#div #contacts #nav class: \"nav-button middle\" children:\n        [#div class: \"icon ion-person-stalker\" text: \"\"]\n        [#div class: \"label\" text: \"contacts\"]]\n      [#div #more #nav class: \"nav-button\" children:\n        [#div class: \"icon ion-android-more-horizontal\" text: \"\"]\n        [#div class: \"label\" text: \"more\"]]]]\n```\n\nAs part of the main application, we display a count of unread messages in the navigation bar:\n\n```\nsearch\n  app = [#app user]\n  threads = [#thread users: user, messages]\n  messages = [#unread]\n\nbind\n  app.unread := count[given: messages]\n```\n\n## Pages\n\nThe application is composed of various pages, that are injected into the main content area depending on the contents of `#app.page`. Only one page should be displayed at a time.\n\n### About Page\n\nDisplays information relating to a contact. This page is constructed in three parts. The first part displays phone and email for the contact:\n\n```\nsearch @browser @session\n  content = [#content]\n  [#app page: [#about contact]]\n\nbind @browser @session\n  content.children := [#div class: \"about\" children:\n    [#div class: \"about-line\", children:\n      [#span class: \"about-label\", text: \"Phone\"]\n      [#span text: contact.phone]]\n    [#div class: \"about-line\", children:\n      [#span class: \"about-label\", text: \"Email\"]\n      [#span text: contact.email]]\n    [#div #recent-contacts children:\n      [#h3 text: \"All Contacts ({{count[given: contact.contacts]}})\"]\n      [#img #contact contact: contact.contacts, class: \"recent-avatar\" src: contact.contacts.avatarURL]]]\n```\n\nIf the user has threads, then recent contacts are displayed:\n\n```\nsearch @browser @session\n  recent-div = [#recent-contacts]\n  [#app page: [#about contact], user]\n  threads = [#thread users: contact messages]\n  recent = threads.users != contact\n\nbind @browser @session\n  recent-div.children += [#div children:\n    [#h3 text: \"Recent Contacts ({{count[given: recent]}})\"]\n    [#img class: \"recent-avatar\" src: recent.avatarURL]]\n```\n\nIf the user has no threads and is looking at his own about page, a message is displayed prompting the user to start a conversation with someone:\n\n```\nsearch @browser @session\n  recent-div = [#recent-contacts]\n  [#app page: [#about contact], user]\n  user = contact\n  not([#thread users: user])\n\nbind @browser\n  recent-div.children += [#div children:\n    [#h3 text: \"Recent Contacts (0)\"]\n    [#div #contacts #nav children:\n      [#div class: \"plus\" text: \"+\"]\n      [#div text: \"Start a Thread\"]]]\n```\n\nIf there is no contact for the about page, then use the current user's info\n\n```\nsearch\n  [#app page user]\n  page = [#about]\n  not(page = [contact])\n\ncommit\n  page.contact := user\n```\n\n### Messages Page\n\nEach message is displayed with the user's avatar and name. An abbreviated timestamp is also displayed.\n\n```\nsearch @browser @session\n  content = [#content]\n  app = [#app page: [#thread thread]]\n  msgs = thread.messages\n  name = if msgs.sender.name = app.user.name then \"Me\"\n         else msgs.sender.name\n  msgs.time = [hours minutes ampm]\n\nbind @browser\n  content.children := [#div class: \"flex-spacer\" children:\n    [#div #convo class: \"convo\" children:\n      [#div sort: msgs.time class: \"msg\" message: msgs children:\n        [#img class: \"msg-avatar\" src: msgs.sender.avatarURL]\n        [#span #contact contact: msgs.sender, class: \"msg-name\" text: name]\n        [#span class: \"msg-time\" text: \"{{hours}}:{{minutes}} {{ampm}}\"]\n        [#div class: \"msg-text\" text: msgs.text]]]\n    [#input #send-message thread class: \"msg-input\"]]\n```\n\n### Threads Page\n\nEach thread is shown with the contact's avatar and name, and the number of messages in the thread.\n\n```\nsearch @browser @session\n  content = [#content]\n  app = [#app page: [#threads], user]\n  thread = [#thread users: user, messages]\n  contacts = thread.users != app.user\n  message-count = count[given: thread.messages, per: thread.users]\n\nbind @browser\n  content.children := [#div thread class: \"thread\" children:\n    [#div #thread thread, class: \"thread-box\" children:\n      [#img class: \"msg-avatar\" src: contacts.avatarURL]\n      [#div class: \"msg-name\" text: contacts.name]\n      [#div text: \"{{message-count}} messages\"]]\n    [#div #archive-button thread class: \"ion-archive\"]]\n```\n\nIf the user has no threads, display a message prompting the user to start a conversation with a contact\n\n```\nsearch @browser @session\n  content = [#content]\n  app = [#app page: [#threads], user]\n  not(threads = [#thread users: user, messages])\n\nbind @browser\n  content.children := [#div #contacts #nav class: \"button\", text: \"Start a Thread\"]\n```\n\n### Contacts Page\n\nContacts are shown with all their contact details. Clicking on a contact opens up a detailed contact page.\n\n```\nsearch @browser @session\n  content = [#content]\n  [#app user page: [#contacts]]\n\nbind @browser @session\n  content.children := [#div #contact contact: user.contacts, class: \"contact\" contact: user.contacts, children:\n    [#img class: \"contact-avatar\" src: user.contacts.avatarURL]\n    [#div class: \"contact-name\", text: user.contacts.name]\n    [#div text: \"Location: {{user.contacts.location}}\"]\n    [#div text: \"Phone: {{user.contacts.phone}}\"]\n    [#div text: \"Email: {{user.contacts.email}}\"]]\n```\n\n### More Page\n\nMore information about Eve!\n\n```\nsearch @browser @session\n  content = [#content]\n  [#app page: [#more]]\n\nbind @browser\n  content.children := [#div #more class: \"more\" children:\n    [#h2 text: \"Learn more about Eve\"]\n    [#ul children:\n      [#li children: [#a href: \"http://witheve.com\" text: \"Homepage\"]]\n      [#li children: [#a href: \"https://witheve.github.io/docs/guides/quickstart/\" text: \"Quick Start Tutorial\"]]\n      [#li children: [#a href: \"http://github.com/witheve\" text: \"GitHub Repository\"]]]\n    [#h2 text: \"Join the Community\"]\n    [#ul children:\n      [#li children: [#a href: \"http://blog.witheve.com\" text: \"Development Diary\"]]\n      [#li children: [#a href: \"https://github.com/witheve/rfcs\" text: \"Request for Comments\"]]\n      [#li children: [#a href: \"https://groups.google.com/forum/#!forum/eve-talk\" text: \"Mailing List\"]]\n      [#li children: [#a href: \"https://twitter.com/with_eve\" text: \"Twitter\"]]]]\n```\n\n## Events\n\n### Set current page\n\nWhen the user clicks on a `#nav` button, set the app page to that element. We use this in subsequent blocks to fill the `#content` area of the app.\n\n```\nsearch @event @browser @session\n  [#click element]\n  element = [#nav]\n  app = [#app user]\n\ncommit\n  app.page := [tag: element.tag]\n  app.contact := none\n```\n\n### Display contact\n\nWhen the user clicks on a contact's name, their \"About\" page is displayed. Otherwise, the user's own \"About\" page is displayed.\n\n```\nsearch @event @browser @session\n  [#click element: [#contact contact]]\n  app = [#app]\n\ncommit\n  app.contact := contact\n  app.page := [#about contact]\n```\n\n### Display messages\n\nMessages are displayed for a current thread. By displaying messages, they are automatically marked as read, which decrements the count on the navigation bar.\n\n```\nsearch @event @browser @session\n  [#click element: [#thread thread]]\n  app = [#app]\n\ncommit\n  app.page := [#thread thread]\n  thread.messages -= #unread\n```\n\n### Send a message\n\nWhen the user presses \"enter\" in the message input box, a message is added to the current thread, with the current time. This event should also clear the input box.\n\n```\nsearch @event @browser @session\n  [#keydown key: \"enter\" element: input]\n  input = [#send-message thread value]\n  [#app user]\n  time = [#time day month year hours minutes seconds ampm]\n\ncommit @browser\n  input.value := \"\"\n  thread.messages += [#message sender: user, time, text: value]\n```\n\n### Archive a thread\n\nWhen the user archives a thread, the `#archive` tag is added to that thread, which then exludes it from display in the main thread list. Archiving a thread also marks all unread messages as read.\n\n- TODO Add a place to see all archived threads\n\n```\nsearch @event @browser @session\n  [#click element: [#archive-button thread]]\n  messages = thread.messages\n\ncommit @session\n  thread += #archived\n  messages -= #unread\n```\n\n## Test Data\n\nThe users and messages in this application are fabricated.\n\n```\nsearch\n  year: 2017\n  month: 10\n  day: 20\n  hours: 10\n  minutes: 20\n  seconds: 30\n  ampm: \"PM\"\n\ncommit\n  corey = [#user\n   name: \"Corey Montella\"\n   title: \"Software Engineer\"\n   avatarURL: \"https://avatars2.githubusercontent.com/u/10619266?v=3&s=466\"\n   location: \"San Francisco, CA\"\n   email: \"corey@kodowa.com\"\n   phone: \"555-555-5555\"]\n\n  chris = [#user\n   name: \"Chris Granger\"\n   title: \"CEO\"\n   avatarURL: \"https://avatars3.githubusercontent.com/u/70036?v=3&s=466\"\n   location: \"San Francisco, CA\"\n   email: \"chris@kodowa.com\"\n   phone: \"555-555-5556\"]\n\n  josh = [#user\n   name: \"Josh Cole\"\n   title: \"Software Engineer\"\n   avatarURL: \"https://avatars2.githubusercontent.com/u/313870?v=3&s=466\"\n   location: \"San Francisco, CA\"\n   email: \"josh@kodowa.com\"\n   phone: \"555-555-5557\"]\n\n  rob = [#user\n   name: \"Rob Attorri\"\n   title: \"President\"\n   avatarURL: \"https://avatars1.githubusercontent.com/u/1314445?v=3&s=466\"\n   location: \"San Francisco, CA\"\n   email: \"rob@kodowa.com\"\n   phone: \"555-555-5558\"]\n\n  eric = [#user\n   name: \"Eric Hoffman\"\n   title: \"Software Engineer\"\n   avatarURL: \"https://avatars3.githubusercontent.com/u/1807982?v=3&s=466\"\n   location: \"San Francisco, CA\"\n   email: \"eric@kodowa.com\"\n   phone: \"555-555-5559\"]\n\n  // Add contacts to users\n  corey.contacts := (chris, josh, rob, eric)\n  chris.contacts := (corey, josh, rob)\n  josh.contacts := (corey, rob, eric)\n  rob.contacts := (corey, josh, chris, eric)\n  eric.contacts := (josh, rob)\n\n  // Make some threads\n  [#thread #new-messages users: (corey, chris) messages:\n    [#message sender: corey, time: [day month year hours minutes seconds: 0 ampm], text: \"Hey\"]\n    [#message sender: chris, time: [day month year hours minutes seconds: 1 ampm], text: \"Hey, how are you.\"]\n    [#message sender: corey, time: [day month year hours minutes seconds: 2 ampm], text: \"I'm fine, how are you?\"]\n    [#message #unread sender: chris, time: [day month year hours minutes seconds: 3 ampm], text: \"Fine as well.\"]\n    [#message #unread sender: chris, time: [day month year hours minutes: minutes + 1, seconds: 4 ampm], text: \"Glad we got that out of the way!\"]\n    [#message #unread sender: chris, time: [day month year hours minutes: minutes + 1 seconds: 5 ampm], text: \"What did you work on yesterday?\"]]\n\n  [#thread users: (corey, josh) messages:\n    [#message sender: josh, time: [day month year hours minutes seconds: 1 ampm], text: \"Hey\"]\n    [#message sender: corey, time: [day month year hours minutes seconds: 2 ampm], text: \"What's up Josh?\"]\n    [#message sender: josh, time: [day month year hours minutes seconds: 3 ampm], text: \"I need to tell you something....\"]\n    [#message sender: corey, time: [day month year hours minutes seconds: 4 ampm], text: \"Uh oh...\"]\n    [#message sender: corey, time: [day month year hours minutes seconds: 5 ampm], text: \"Well what is it? Don't leave me hanging!\"]]\n\n  [#thread #new-messages users: (corey, rob) messages:\n    [#message sender: corey, time: [day month year hours minutes seconds: 0 ampm], text: \"Did Josh tell you what happened?\"]\n    [#message sender: rob, time: [day month year hours minutes seconds: 1 ampm], text: \"Yeah, don't worry, we took care of it. \"]\n    [#message sender: corey, time: [day month year hours minutes seconds: 2 ampm], text: \"Well what happened?\"]\n    [#message sender: rob, time: [day month year hours minutes seconds: 3 ampm], text: \"Like I said, don't worry about it.\"]\n    [#message sender: corey, time: [day month year hours minutes seconds: 4 ampm], text: \"...\"]\n    [#message #unread sender: rob, time: [day month year hours minutes seconds: 5 ampm], text: \"ðŸ”¥\"]]\n```\n","analyzer.eve":"# Eve Analyzer\n\n## assign variables\n\nFor every variable there is a group\n\n~~~eve disabled\nsearch\n  variable = [#variable]\n  number = random[seed: variable]\ncommit\n  [#group number variable]\n~~~\n\n~~~eve disabled\nsearch\n  variable = [#variable not(group)]\n  group = [#group variable]\ncommit\n  variable.group := group\n~~~\n\nHandle a constant equivalence\n\n~~~eve disabled\nsearch\n  eq = [#equality]\n  (a, b) = if eq.a.tag, not(eq.b.tag) then (eq.a, eq.b)\n            else if eq.b.tag, not(eq.a.tag) then (eq.b, eq.a)\nbind\n  a.constant += b\n~~~\n\nHandle variable equivalence\n\n~~~eve disabled\nsearch\n  [#equality a b]\n  a.group != b.group\n  min-a = min[value: a.group.number, given: a.group.number, per: a]\n  min-b = min[value: b.group.number, given: b.group.number, per: b]\n  a-group = [#group number: min-a]\n  b-group = [#group number: min-b]\n  (new, old) = if min-a < min-b then (a-group, b-group)\n                else if min-b < min-a then (b-group, a-group)\n  var = [#variable group: old]\ncommit\n  var.group := new\n~~~\n\n## associate record-tags to both actions and scans\n\nAny scan attached to a pattern that is looking for our record-tag is\nrelated to that tag.\n\n~~~\nsearch\n  [#query record-tag]\n  [#scan entity: [register] attribute: \"tag\" value: record-tag block]\n  scan = [#scan entity: [register] block]\nbind\n  scan.record-tag += record-tag\n~~~\n\nAny action attached to a pattern that is looking for our record-tag is\nrelated to that tag.\n\n~~~\nsearch\n  [#query record-tag]\n  [#action entity: [register] attribute: \"tag\" value: record-tag block]\n  action = [#action entity: [register] block]\nbind\n  action.record-tag += record-tag\n~~~\n\n\nActions that are adding to an entity with our record tag, are also for the\nsame record-tag.\n\n~~~\nsearch\n  [#query record-tag]\n  [#scan entity: [register] record-tag block]\n  action = [#action entity: [register] block]\nbind\n  action.record-tag += record-tag\n~~~\n\nThe inverse is true as well, if an action is for our record tag and the entity\nis used in a scan, then that scan is for this tag.\n\n~~~\nsearch\n  [#query record-tag]\n  [#action entity: [register] record-tag block]\n  scan = [#scan entity: [register] block]\nbind\n  scan.record-tag += record-tag\n~~~\n\n## tag equivalence\n\n~~~\n  search\n    attribute = \"tag\"\n    [#scan block entity: [register] attribute value: tag]\n    [#action block entity: [register] attribute value: tag2]\n  bind\n    [#tag-equivalence tag tag2]\n~~~\n\n## unprovided scans\n\n~~~ eve disabled\n  search\n    scan = [#scan record-tag attribute]\n    not( action = [#action record-tag attribute]\n        value = if scan.value = action.value then true\n                else if scan.value = [#variable] then true\n                else if action.value = [#variable] then true )\n  bind\n    scan += #unprovided\n~~~\n\n~~~ eve disabled\n  search\n    scan = [#scan #analyzer/any attribute]\n    not( action = [#action attribute]\n        value = if scan.value = action.value then true\n                else if scan.value = [#variable] then true\n                else if action.value = [#variable] then true )\n  bind\n    scan += #unprovided\n~~~\n\n~~~ eve disabled\nsearch\n  scan = [#scan #unprovided start stop record-tag attribute block]\nbind @editor\n  [#comment scan | block start stop message: \"{{attribute}} is never added to {{record-tag}} records, so this will always be empty\"]\n~~~\n\n# token query\n\n## query links\n\n~~~\nsearch\n  query = [#query token]\n  [#link a: to b: token]\nbind\n  [#query-link token to distance: 1]\n~~~\n\n~~~\nsearch\n  query = [#query token]\n  link = [#query-link token distance]\n  [#link a: to b: link.to]\nbind\n  [#query-link token to distance: distance + 1]\n~~~\n\n## token -> variable\n\n~~~\nsearch\n  query = [#query token]\n  [#link a: to b: token]\n  to = [#variable register block]\n  token.block = block\nbind\n  query.register += [token variable: to register block name: to.name]\n~~~\n\nWe can also associate what attribute that variable is writing to if there is one\n\n~~~\nsearch\n  query = [#query register]\n  action = [#action attribute value: register.variable]\nbind\n  register.attribute += attribute\n~~~\n\n## token -> scan\n\n~~~\nsearch\n  query = [#query token]\n  [#query-link token to]\n  to = [#scan start stop]\n  start <= token.start <= stop\nbind\n  query.scan += to\n~~~\n\n~~~\nsearch\n  [#query token scan: [#scan record-tag attribute value]]\n  provider = [#action record-tag attribute start stop]\nbind @editor\n  [#comment provider | start stop kind: \"warning\" message: \"this is providing it\" ]\nbind @browser\n  [#div text: \"provided by: {{provider}}\"]\n~~~\n\n~~~\nsearch\n  [#query token scan: [#scan record-tag attribute]]\nbind @browser\n  [#div text: \"{{token}} scans #{{record-tag}} {{attribute}}\"]\n~~~\n\n## token -> action\n\n~~~\nsearch\n  query = [#query token]\n  [#query-link token to]\n  to = [#action start stop]\n  start <= token.start <= stop\nbind\n  query.action += to\n~~~\n\n~~~\nsearch\n  [#query token action: [#action record-tag attribute]]\n  consumer = [#scan record-tag attribute start stop]\nbind @editor\n  [#comment consumer | start stop kind: \"warning\" message: \"This is consuming\" ]\nbind @browser\n  [#div text: \"consumed by: {{consumer}}\"]\n~~~\n\n~~~\nsearch\n  [#query token action: [#action record-tag attribute]]\nbind @browser\n  [#div text: \"{{token}} actions #{{record-tag}} {{attribute}}\"]\n~~~\n\n## token -> record\n\n~~~\nsearch\n  query = [#query]\n  entity = if query.scan then query.scan.entity\n           else if query.action then query.action.entity\n  record = [#record entity start stop]\nbind\n  query <- [entity entity-register: entity.register]\n~~~\n\n\n## find variables related to a span\n\nDetermine the kind of span we're looking for\n\n~~~\nsearch\n  query = [#findRelated for: \"span\" span]\n  kind = if span = [#action] then \"action\"\n         else if span = [#scan] then \"scan\"\n         else if span = [#record kind] then kind\nbind\n  query.kind := kind\n~~~\n\nIf the span is an action, we need to find the variables related to both the\nvalue and the entity\n\n~~~\nsearch\n  query = [#findRelated for: \"span\" span kind]\n  span = [tag: kind entity value]\n  variable = if entity = [#variable] then entity\n             if value = [#variable] then value\n  [#link a: variable b: token]\nbind\n  query.variable += token\n~~~\n\nIf the span is a record, we need to find all the actions directly related to it\n\n~~~\nsearch\n  query = [#findRelated for: \"span\" span]\n  span = [#record entity start stop kind]\n  scan = [tag: kind, entity]\n  scan.start >= start\n  scan.stop <= stop\n  scan.value = [#variable]\n  [#link a: scan.value b: token]\n  [#link a: entity b: entity-token]\nbind\n  query.variable += entity-token\n  query.variable += token\n~~~\n\nif one of the variables we found is the entity for another scan/action, then we need\nto add him to the list of things we want to find relateds for\n\n~~~\nsearch\n  query = [#findRelated for: \"span\" kind variable]\n  [#link a: entity b: variable]\n  span = [tag: kind entity]\nbind\n  query.span += span\n~~~\n\n## findValue\n\n~~~\nsearch\n  query = [#findValue]\n~~~\n\n## findCardinality\n\n~~~\nsearch\n  query = [#findCardinality]\n~~~\n\n## find spans related to a variable\n\n~~~\nsearch\n  query = [#findRelated for: \"variable\" variable: token]\n  [#link a: variable b: token]\n  span = if span.entity = variable then span\n         if span.value = variable then span\nbind\n  query.span += span\n~~~\n\n## recordId ->  build-node\n\n~~~\nsearch\n  query = [#findSource recordId not(attribute)]\nsearch @evaluation-session @evaluation-browser\n  recordId = [tag]\nbind\n  query.cool += tag\n~~~\n\nFind out what nodes contribute to a record\n\n~~~\nsearch\n  query = [#findSource recordId not(attribute)]\nsearch @evaluation-session @evaluation-browser\n  lookup[record: recordId, attribute, value, node]\nbind\n  query.node += node\n~~~\n\nFind out what nodes contribute to a specific attribute on a record\n\n~~~\nsearch\n  query = [#findSource recordId attribute]\nsearch @evaluation-session @evaluation-browser\n  lookup[record: recordId, attribute, value, node]\nbind\n  query.node += node\n~~~\n\nWe may also want to lookup what node created a complete eav\n\n~~~\nsearch\n  query = [#findSource recordId attribute value]\nsearch @evaluation-session @evaluation-browser\n  lookup[record: recordId, attribute, value, node]\nbind\n  query.node += node\n~~~\n\n## scan to block\n\n~~~\nsearch\n  query = [#findSource span: [block]]\nbind\n  query.block += block\n~~~\n\n## nodeId -> creator (aka findSource)\n\n~~~\nsearch\n  query = [#findSource node]\n  action = [#action entity build-node: node block]\n  span = if query.attribute then action\n         else if record = [#record entity] then record\n         else action\nbind\n  query.source += [span block start: span.start, stop: span.stop]\n~~~\n\n## build-node to creator\n\n~~~\nsearch\n  query = [#query build-node]\n  [#action entity build-node]\n  record = [#record entity]\ncommit\n  query.pattern := record\n~~~\n\n## findRecordsFromToken\n\nAdd the #query tag so that we find all the scans/actions related to the given\ntoken\n\n~~~\nsearch\n  query = [#findRecordsFromToken]\ncommit\n  query += #query\n~~~\n\n~~~\nsearch\n  query = [#findRecordsFromToken token]\n  [#query-link token to]\n  to = [#action build-node]\ncommit\n  query.build-node += build-node\n~~~\n\n~~~\nsearch\n  query = [#findRecordsFromToken token]\n  [#query-link token to]\n  to = [#action build-node]\nsearch @evaluation-session @evaluation-browser\n  lookup[node: build-node, record]\ncommit\n  query.record += record\n~~~\n\n## findAffector\n\nStore what record-tag we need to compute providers and consumers for\n\n~~~\nsearch\n  query = [#findAffector recordId]\nsearch @evaluation-session @evaluation-browser\n  tag = recordId.tag\nbind\n  query += #query\n  query.record-tag += tag\n~~~\n\nFind affectors based on what providers and consumers exist\n\n~~~\nsearch\n  query = [#findAffector recordId attribute record-tag]\n  scan = [#scan entity: [register] record-tag block]\n  action = [#action entity: [register] block attribute]\n  final = if record = [#record entity: [register] start stop]\n             action.start >= start\n             action.stop <= stop then record\n          else action\nbind\n  query.affector := [action: final, block]\n~~~\n\n~~~\nsearch\n  query = [#findAffector recordId attribute]\n  //scan = [#scan entity: [register] record-tag: tag block]\n  //action = [#action entity: [register] attribute block ]\nsearch @evaluation-session @evaluation-browser\n  recordId = [tag]\nbind @browser\n  //[#div text: \"yo {{tag}}\"]\n~~~\n\n\n## findRootDrawers\n\n~~~\nsearch\n  query = [#findRootDrawers]\n  action = [#action block entity: [register] scopes: \"browser\"]\n  not([#scan block entity: [register]])\n  not([#action block value: [register]])\n  final = if record = [#record entity: [register] start stop]\n             action.start >= start\n             action.stop <= stop then record\n          else action\ncommit\n  query.drawer += [id: final start: final.start stop: final.stop]\n~~~\n\n\n## findMaybeDrawers\n\n~~~\ncommit\n  [#drawing-tag tag: \"div\"]\n  [#drawing-tag tag: \"span\"]\n  [#drawing-tag tag: \"img\"]\n  [#drawing-tag tag: \"input\"]\n  [#drawing-tag tag: \"button\"]\n~~~\n\n~~~\nsearch\n  query = [#findMaybeDrawers]\n  [#drawing-tag tag: drawing-tag]\n  action = [#action entity: [register] block attribute: \"tag\" value: drawing-tag]\n  not(action.scopes = \"browser\")\n  final = if record = [#record entity: [register] start stop]\n             action.start >= start\n             action.stop <= stop then record\n          else action\ncommit\n  query.drawer += [id: final start: final.start stop: final.stop ]\n~~~\n\n","attendance-bug.eve":"# Attendance Bug\n\nThis is a simple webapp with an equally simple issue: When navigated to the \"attendance\" page, nothing shows up! It provides a playground for using the inspector (the magic wand button in the top right of the editor). By clicking the inspect button and then anything in the IDE, Eve will tell you what it knows about your target. From there, it works with you to understand both what was intended and what's actually happening. The inspector is still in its infancy, so the UX is pretty rough. Any and all feedback is welcome on the [mailing list](https://groups.google.com/forum/#!forum/eve-talk).\n\n### Setup\n\nCreate some students, teachers, syllabi, and schools.\n\n```\ncommit\n  middlington = [#school name: \"Middlington Jr. High\"]\n\n  [#student name: \"John\" school: middlington class: 1 grade: 85 absences: 1]\n  [#student name: \"Beth\" school: middlington class: 1 grade: 78 absences: 4]\n  [#student name: \"Jorge\" school: middlington class: 2 grade: 92 absences: 1]\n  [#student name: \"Rin\" school: middlington class: 1 grade: 91 absences: 0]\n\n  user = [#teacher name: \"George\" school: middlington class: 1]\n  [#teacher name: \"Alice\" school: middlington class: 2]\n\n  [#syllabus name: \"Intro to Introductory Courses\" class: 1 | assignment: (\"homework 1\", \"homework 2\", \"quiz 1\", \"finals\")]\n  [#syllabus name: \"Advanced Rocket Surgery\" class: 2 | assignment: (\"self study\", \"group project\", \"finals\")]\n\n  [#app page: \"grades\" user]\n```\n\n### Events\n\nWhen a `#nav` button is clicked, update the app's current page.\n\n```\nsearch @event\n  [#click #direct-target element]\n\nsearch @browser\n  element = [#button #nav app text: page]\n\ncommit\n  app.page := page\n```\n\n### Drawing\n\nDraw the page template. The specific page will be drawn into `#content` later on.\n\n```\nsearch\n  app = [#app]\n\nbind @browser\n  app <- [#div children:\n    [#div style: [margin-bottom: 20] children:\n      [#button #nav app text: \"grades\"]\n      [#button #nav app text: \"syllabus\"]\n      [#button #nav app text: \"attendance\"]]\n    [#div #content app style: [min-height: 500] sort: 2]]\n```\n\n### Pages\n\nWhen the page is \"grades\", show the student's grades for the current teacher.\n\n```\nsearch\n  app = [#app page: \"grades\" user: teacher]\n  student = [#student name school: teacher.school class: teacher.class grade]\n  ix = sort[value: name]\n\nsearch @browser\n  content = [#content app]\n\nbind @browser\n  content <- [children:\n    [#header sort: 0 text: \"Grades for {{teacher.name}}'s class\"]\n    [#div sort: ix text: \"{{name}}'s grade is {{grade}}\"]]\n\n```\n\nWhen the page is \"syllabus\", show the syllabus for the current teacher's class.\n\n```\nsearch\n  app = [#app page: \"syllabus\" user: teacher]\n  syllabus = [#syllabus class: teacher.class assignment]\n\nsearch @browser\n  content = [#content app]\n\nbind @browser\n  content <- [children:\n    [#header sort: 0 text: \"Syllabus for {{syllabus.name}}\"]\n    [#div text: assignment]]\n```\n\nWhen the page is \"attendance\", show each student's number of absences.\n\n```\nsearch\n  app = [#app page: \"attendance\" user: teacher]\n  teacher.school = [#school name]\n  student = [#student name school: teacher.school class: teacher.class grade]\n  ix = sort[value: name]\n\nsearch @browser\n  content = [#content app]\n\nbind @browser\n  content <- [children:\n    [#header sort: 0 text: \"Attendance for {{name}}\"]\n    [#div sort: ix text: \"{{name}}'s grade is {{grade}}\"]]\n```\n","clock.eve":"# Clock\n\nDraw an appropriately positioned line into `#clock-hand`s.\n\n```\n  search @browser\n    hand = [#clock-hand angle length]\n    x2 = 50 + (length * sin[angle])\n    y2 = 50 - (length * cos[angle])\n  bind @browser\n    hand <- [#line, x1: 50, y1: 50, x2, y2]\n```\n\nDraw a clock using SVG. We find the angle for each hand using time and let the `#clock-hand` block take care of the rest.\n\n```\n  search\n    [#time hours minutes seconds]\n  bind @browser\n    [#svg viewBox: \"0 0 100 100\", width: \"300px\", children:\n      [#circle cx: 50, cy: 50, r: 45, fill: \"#0B79CE\"]\n      [#clock-hand #hour-hand angle: 30 * hours, length: 30, stroke: \"#023963\"]\n      [#clock-hand #minute-hand angle: 6 * minutes, length: 40, stroke: \"#023963\"]\n      [#clock-hand #second-hand angle: 6 * seconds, length: 40, stroke: \"#ce0b46\"]]\n```\n","counter.eve":"# Counter\n\nThis program demonstrates:\n\n- responding to events\n- drawing elements on the screen\n- reusing elements programatically\n- extending an element\n\n### Increment a Counter\n\nEach button uses the referenced counter to increment itself. We need to search on three databases to accomplish this goal:\n\n- `#click` is in `@event`.\n- `#button` is in `@browser`\n- `counter.count` is in `@session`\n\n```\nsearch @event @browser @session\n  [#click #direct-target element: [#button diff counter]]\n\ncommit\n  counter.count := counter.count + diff\n```\n\n### Build a Counter\n\nFor every `#counter`, we create a `#div` that contains the elements that draw the counter. The counters are added to the root of the DOM, but you could add them to a particular element in the DOM by specifying a parent element.\n\n```\nsearch\n  counter = [#counter count]\n\nbind @browser\n  [#div counter class: \"flex-row\" style: [flex: \"0 0 auto\", width: 80] children:\n    [#button text: \"-\", diff: -1, counter]\n    [#div text: count counter style: [padding: \"0 6px\" flex: 1]]\n    [#button text: \"+\", diff: 1, counter]]\n```\n\nAdd some counters programatically. To make `n` unique and independent counters, we need to add something to the committed counter that makes it unique. Since `i` = `{1, 2, 3, 4}`, when we add it to the counter record we get 4 different counters. We also add one `#fancy` counter, which is a standard counter with new styling.\n\n```\nsearch\n  i = range[from: 1 to: 4]\n\ncommit\n  [#counter i count: 0]\n  [#counter #fancy count: 0]\n```\n\n### Extend the Counter\n\nThis block says: \"For every div with a counter that is tagged fancy, add a style with a black background and pink text\". Let's break it down. We search for all `#div`s with a counter attribute. The counter is constrained to be only counters with a `#fancy` tag. Then we bind a new style to each.\n\n```\nsearch @browser @session\n  counter-element = [#div counter]\n  counter.tag = \"fancy\"\n\nbind @browser @session\n  counter-element.style += [background: \"black\" color: \"#FFD0E0\"]\n```\n","editor.eve":"# Editor Bootstrap\n\nThis DB allows Eve programs to interact directly with the editor.\n\n## Editor Actions\n\nActions allow remotely controlling the editor.\n\n### Inspect\n\n`#inspect` will enable inspector interactions in the editor. While this is on, additional mouse and cursor events will be attached to the editor to forward the user's current spans / elements of interest to the `@inspector` DB. When the action is removed, inspector mode will be disabled.\n\n```\nsearch @editor\n  action = [#inspect]\n\nbind @inspector\n  action <- [#inspector]\n\nbind @browser\n  action <- [#editor #inspect]\n```\n\n### Jump To\n\n`#jump-to` will scroll the editor viewport to bring the given `span` or index `position` into view. If multiple `span` and/or `position`s are specified, the topmost will be scrolled to.\n\n```\nsearch @editor\n  action = [#jump-to]\n  (attribute, value) = if action.span then (\"span\", action.span)\n                       if action.position then (\"position\", action.position)\n\nbind @browser\n  result = [#editor #jump-to]\n  lookup[record: result, attribute, value]\n```\n\n### Mark Between\n\n`#mark-between` will create new spans of the specified `type` *between* the given `span`s or `range`s. If `within` (a span id) is specified, it will constrain itself within that span. Otherwise it will go to the beginnning and end of the document. When the action is removed, the associated spans will be removed from the editor.\n\n```\nsearch @editor\n  action = [#mark-between type span]\n\nbind @browser\n  action <- [#editor #mark-between type span]\n```\n\n```\nsearch @editor\n  action = [#mark-between type range]\n\nbind @browser\n  range <- [start: range.start stop: range.stop]\n  action <- [#editor #mark-between type range]\n```\n\nInclude the optional within attribute, if specified.\n\n```\nsearch @editor\n  action = [#mark-between within]\n\nbind @browser\n  action <- [within]\n```\n\n### Mark Span\n\n`#mark-span` will create a new span on the same range as the given `span`s of the specified `type`. When the action is removed, the associated spans will be removed from the editor.\n\n@NOTE: Mark span must be special cased to copy over all possible optional attributes right now. This is sad.\n\n```\nsearch @editor\n  action = [#mark-span type span]\n\nbind @browser\n  action <- [#editor #mark-span type span]\n```\n\nCopy optional `message` attribute over if provided.\n\n```\nsearch @editor\n  action = [#mark-span message]\n\nbind @browser\n  action <- [message]\n```\n\nCopy optional `kind` attribute over if provided.\n\n```\nsearch @editor\n  action = [#mark-span kind]\n\nbind @browser\n  action <- [kind]\n```\n\n### Mark Range\n\n`#mark-range` will create a new span using `start` and `stop` as indexes into the text of the current document. When the action is removed, the associated span will be as well.\n\n```\nsearch @editor\n  action = [#mark-range type start stop]\n\nbind @browser\n  action <- [#editor #mark-range type start stop]\n```\n\nCopy any attributes besides tag over. They'll be used to populate the span's source.\n\n```\nsearch @editor\n  action = [#mark-range]\n  lookup[record: action, attribute, value]\n  attribute != \"tag\"\n  attribute != \"type\"\n  attribute != \"start\"\n  attribute != \"stop\"\n\nbind @browser\n  lookup[record: action, attribute, value]\n```\n\n### Elide Between Sections\n\n`#elide-between-section` will elide all sections that do not contain at least one of the given `span`(s) or `position`(s). When the action is removed, these elisions will be cleared.\n\n```\nsearch @editor\n  action = [#elide-between-sections span]\n\nbind @browser\n  [#editor #elide-between-sections | span]\n```\n\n```\nsearch @editor\n  action = [#elide-between-sections position]\n\nbind @browser\n  [#editor #elide-between-sections | position]\n```\n\n### Find Section\n\n`#find-section` will find the section (region under the nearest heading) containing the given `position` (as an index into the document text) or `span` id. Results will be returned in the format `[#section position? span? heading start stop]` where `position` and `span` are as provided, heading is the id of the heading span for the section (if any), and `start` and `stop` are the indexes for the beginning and end of the section.\n\n```\nsearch @editor\n  action = [#find-section span]\n\nbind @browser\n  [#editor #find-section span]\n```\n\n```\nsearch @editor\n  action = [#find-section position]\n\nbind @browser\n  [#editor #find-section position]\n```\n\n```\nsearch @event\n  event = [#editor #section action]\n  (attribute, value) = if event.position then (\"position\", event.position)\n                       if event.span then (\"span\", event.span)\n                       if event.heading then (\"heading\", event.heading)\n                       if event.start then (\"start\", event.start)\n                       if event.stop then (\"stop\", event.stop)\n\ncommit @editor\n  section = [#section action]\n  lookup[record: section, attribute, value]\n```\n\n```\nsearch @editor\n  section = [#section action]\n  not(action = [#find-section])\n\ncommit @editor\n  section := none\n```\n\n## Language Service\n\nThe Language Service allows Eve to query the analyzer for information about the currently running program.\n\n### Find Source\n\n`#find-source` will request the originating source span(s) for a given `record` id, `record`, `attribute` pair, or `span` ids. from the language service. Results will be returned in the format `[#source record? attribute? span? block]`, where `record`, `attribute` are the same as provided. `span` is the same if provided or originating spans if not, and block is the set of source blocks. These records will be maintained by the editor until the action is removed, at which point they will be removed from the DB.\n\n```\nsearch @editor\n  action = [#find-source]\n  (attribute, value) = if action.record then (\"record\", action.record)\n                       if action.attribute then (\"attribute\", action.attribute)\n                       if action.span then (\"span\", action.span)\n\nbind @browser\n  action = [#editor #find-source]\n  lookup[record: action, attribute, value]\n```\n\nWhen a source event comes in, persist it into the editor and clear it from the event bag.\n\n```\nsearch @event\n  event = [#editor #source action]\n  (attribute, value) = if event.record then (\"record\", event.record)\n                       if event.attribute then (\"attribute\", event.attribute)\n                       if event.span then (\"span\", event.span)\n                       if event.block then (\"block\", event.block)\n\ncommit @editor\n  source = [#source action]\n  lookup[record: source, attribute, value]\n\ncommit @event\n  event := none\n```\n\nWhen a source's supporting action is removed, remove it.\n```\nsearch @editor\n  source = [#source action]\n  not(action = [#find-source])\n\ncommit @editor\n  source := none\n```\n\n\n### Find Related\n\n`#find-related` will request all related `span`(s) for a given `variable` or `variable`(s) for a `span` from the language service. Related spans are spans which are directly joined to or unified with the target.  Results will be returned in the format `[#related span? variable?]`, where the argument you provided is the same and the other is filled in. These records will be maintained by the editor until the action is removed, at which point they will be removed from the DB.\n\n```\nsearch @editor\n  [#find-related variable]\n\nbind @browser\n  [#editor #find-related | variable]\n```\n\n```\nsearch @editor\n  [#find-related span]\n\nbind @browser\n  [#editor #find-related | span]\n```\n\nWhen a related event comes in, persist it into the editor and clear it from the event bag.\n```\nsearch @event\n  event = [#editor #related action variable span]\n\ncommit @editor\n  event <- [#related action variable span]\n\ncommit @event\n  event := none\n```\n\nWhen a related's supporting action is removed, remove it.\n```\nsearch @editor @browser\n  related = [#related action]\n  not(action = [#find-related])\n\ncommit @editor\n  related := none\n```\n\n### Find Value\n\n`#find-value` will request the intermediate value(s) for the given set of `variable`(s) from the language service. By default, all intermediates for the variables will be returned. If `given` is specified, containing a set of `[attribute value]` pairs, only values that exist in the same \"row\" as the fixed values will be returned. If multiple values are provided for a variable, the results for each will be logically unioned. Results will be returned in the format `[#value variable value row]`, where `variable` is one of the given `variable`s, `value` is the intermediate value of the variable, and `row` is the \"row\" the intermediate is from (for matching intermediates of different variables up). These records will be maintained by the editor until the action is removed, at which point they will be removed from the DB.\n\nIf given isn't specified, we'll find up to 100 rows out of all the rows from the block.\n\n```\nsearch @editor\n  action = [#find-value variable not(given)]\n\nbind @browser\n  action <- [#editor #find-value variable]\n```\n\nIf it is, we'll filter by it to only include relevant rows.\n\n```\nsearch @editor\n  action = [#find-value variable given: [attribute value]]\n\nbind @browser\n  given = [attribute value]\n  action <- [#editor #find-value variable given]\n```\n\nWhen a value event comes in, persist it into the editor and clear it from the event bag.\n```\nsearch @event\n  event = [#editor #value action variable value row name register]\n\ncommit @editor\n  event <- [#value action variable value row name register]\n\ncommit @event\n  event := none\n```\n\nWhen a value's supporting action is removed, remove it.\n```\nsearch @editor @browser\n  value = [#value action]\n  not(action = [#find-value])\n\ncommit @editor\n  value := none\n```\n\n\n### Find Cardinality\n\n`#find-cardinality` will request the cardinalities for the given set of `variable`(s) from the language service. The cardinality is the number of unique values that could satisfy `variable`. Results will be returned in the format `[#cardinality variable cardinality]` where `variable` is as given and cardinality is the count of satisfying values available. These records will be maintained by the editor until the action is removed, at which point they will be removed from the DB.\n\n```\nsearch @editor\n  action = [#find-cardinality variable]\n\nbind @browser\n  [#editor #find-cardinality | variable]\n```\n\n\nWhen a value event comes in, persist it into the editor and clear it from the event bag.\n```\nsearch @event\n  event = [#editor #cardinality action variable cardinality]\n\ncommit @editor\n  event <- [#cardinality action variable cardinality]\n\ncommit @event\n  event := none\n```\n\nWhen a value's supporting action is removed, remove it.\n```\nsearch @editor @browser\n  cardinality = [#cardinality action]\n  not(action = [#find-cardinality])\n\ncommit @editor\n  cardinality := none\n```\n\n### Find Affector\n\n```\nsearch @editor\n  action = [#find-affector]\n  (attribute, value) = if action.record then (\"record\", action.record)\n                       if action.attribute then (\"attribute\", action.attribute)\n                       if action.span then (\"span\", action.span)\n\nbind @browser\n  result = [#editor #find-affector]\n  lookup[record: result, attribute value]\n```\n\nWhen an affector event comes in, persist it into the editor and clear it from the event bag.\n```\nsearch @event\n  event = [#editor #affector action]\n  (attribute, value) = if event.record then (\"record\", event.record)\n                       if event.attribute then (\"attribute\", event.attribute)\n                       if event.span then (\"span\", event.span)\n                       if event.block then (\"block\", event.block)\n                       if event.action then (\"action\", event.action)\n\ncommit @editor\n  event <- [#affector action]\n  lookup[record: event, attribute, value]\n\ncommit @event\n  event := none\n```\n\nWhen an affector's supporting action is removed, remove it.\n```\nsearch @editor @browser\n  affector = [#affector action]\n  not(action = [#find-affector])\n\ncommit @editor\n  affector := none\n```\n\n### Find Failure\n\n```\nsearch @editor\n  action = [#find-failure block]\n\nbind @browser\n  [#editor #find-failure | block]\n```\n\n```\nsearch @event\n  event = [#editor #failure action block start stop]\n\ncommit @editor\n  event <- [#failure action block start stop]\n\ncommit @event\n  event := none\n```\n\n```\nsearch @editor @browser\n  failure = [#failure action]\n  not(action = [#find-failure])\n\ncommit @editor\n  failure := none\n```\n\n### Find Root Drawers\n\n```\nsearch @editor\n  action = [#find-root-drawers]\n\nbind @browser\n  action <- [#editor #find-root-drawers]\n```\n\n```\nsearch @event\n  event = [#editor #root-drawer action span start stop]\n\ncommit @editor\n  event <- [#root-drawer action span start stop]\n\ncommit @event\n  event := none\n```\n\n```\nsearch @editor @browser\n  drawer = [#drawer action]\n  not(action = [#find-root-drawer])\n\ncommit @editor\n  drawer := none\n```\n\n### Find Performance\n\n```\nsearch @editor\n  action = [#find-performance]\n\nbind @browser\n  action <- [#editor #find-performance]\n```\n\n```\nsearch @event\n  event = [#editor #performance action block average calls color max min percent total]\n\ncommit @editor\n  event <- [#performance action block average calls color max min percent total]\n\ncommit @event\n  event := none\n```\n\n```\nsearch @editor @browser\n  performance = [#performance action]\n  not(action = [#find-performance])\n\ncommit @editor\n  performance := none\n```\n","event.eve":"remove events\n~~~\n  search @event\n    c = if event = [#keydown] then event\n        if event = [#keyup] then event\n        if event = [#click] then event\n        if event = [#double-click] then event\n        if event = [#change] then event\n        if event = [#blur] then event\n        if event = [#focus] then event\n        if event = [#url-change] then event\n  commit @event\n    c := none\n~~~\n\nhash changes\n~~~\n  search @event\n    change = [#url-change hash-segment]\n    hash-segment = [index value]\n  commit @browser\n    url = [#url]\n    url.hash-segment := [index value]\n~~~\n\nupdate values\n~~~\n  search @event\n    c = [#change element value]\n  commit @browser\n    element.value := value\n~~~\n","flappy.eve":"# Flappy Eve\n\nWhen a player starts the game, we commit a `#world`, a `#player`, and some `#obstacles`. These will keep all of the essential state of the game. All of this information could have been stored on the world, but for clarity we break the important bits of state into objects that they effect.\n\n- The `#world` tracks the distance the player has travelled, the current game screen, and the high score.\n- The `#player` stores his current y position and (vertical) velocity.\n- The `obstacles` have their (horizontal) offset and gap widths. We put distance on the world and only keep two obstacles; rather than moving the player through the world, we keep the player stationary and move the world past the player. When an obstacle goes off screen, we will wrap it around, update the placement of its gap, and continue on.\n\n## Setup\n\nAdd a flappy eve and a world for it to flap in:\n\n```\ncommit\n  [#player #self name: \"eve\" x: 25 y: 50 velocity: 0]\n  [#world screen: \"menu\" frame: 0 distance: 0 best: 0 gravity: -0.061]\n  [#obstacle gap: 35 offset: 0]\n  [#obstacle gap: 35 offset: -1]\n```\n\nNext we draw the backdrop of the world. The player and obstacle will be drawn later based on their current state. Throughout the app we use resources from [@bhauman's flappy bird demo in clojure][1]. Since none of these things change over time, we commit them once when the player starts the game.\n\n### Draw the game world!\n\n```\nsearch\n  world = [#world]\n\ncommit @browser\n  world <- [#div style: [user-select: \"none\" -webkit-user-select: \"none\" -moz-user-select: \"none\"]  children:\n    [#svg #game-window viewBox: \"10 0 80 100\", width: 480 children:\n      [#rect x: 0 y: 0 width: 100 height: 53 fill: \"rgb(112, 197, 206)\" sort: 0]\n      [#image x: 0 y: 52 width: 100 height: 43 preserveAspectRatio: \"xMinYMin slice\" href: \"https://cdn.rawgit.com/bhauman/flappy-bird-demo/master/resources/public/imgs/background.png\" sort: 1]\n      [#rect x: 0 y: 95 width: 100 height: 5 fill: \"rgb(222, 216, 149)\" sort: 0]]]\n```\n\n## Game menus\n\nThese following blocks handle drawing the game's other screens (such as the main menu and the game over scene).\n\nThe main menu displays a message instructing the player how to start the game.\n\n```\nsearch @browser @session\n  [#world screen: \"menu\"]\n  svg = [#game-window]\n\nbind @browser\n  svg.children += [#text x: 50 y: 45 text-anchor: \"middle\" font-size: 6 text: \"Click the screen to begin!\" sort: 10]\n```\n\nThe \"game over\" screen displays the final score of the last game, the high score of all games, and a message inviting the player to play the game again.\n\n```\nsearch @session @browser\n  [#world screen: \"game over\" score best]\n  svg = [#game-window]\n\nbind @browser\n  svg.children += [#text x: 50 y: 30 text-anchor: \"middle\" font-size: 6 text: \"Game Over :(\" sort: 10]\n  svg.children += [#text x: 50 y: 55 text-anchor: \"middle\" font-size: 6 text: \"Score {{score}}\" sort: 10]\n  svg.children += [#text x: 50 y: 65 text-anchor: \"middle\" font-size: 6 text: \"Best {{best}}\" sort: 10]\n  svg.children += [#text x: 50 y: 85 text-anchor: \"middle\" font-size: 4 text: \"Click to play again!\" sort: 10]\n```\n\n### Score calculation\n\nWe haven't calculated the score yet, so let's do that. We calculate the score as the `floor` of the distance, meaning we just round the distance down to the nearest integer. If the distance between pipes is changed, this value can be scaled to search.\n\n```\nsearch\n  world = [#world distance]\n\nbind\n  world.score := floor[value: distance]\n```\n\n### Start a new game\n\nWhen the game is on the \"menu\" or \"game over\" screens, a click anywhere in the application will (re)start the game. Additionally, if the current score is better than the current best, we'll swap them out now. Along with starting the game, we make sure to reset the distance and player positions in the came of a restart.\n\n```\nsearch @event @session\n  [#click element: [#world]]\n  world = if world = [#world screen: \"menu\"] then world\n          else [#world screen: \"game over\"]\n  new = if world = [#world score best] score > best then score\n        else if world = [#world best] then best\n  player = [#player]\n\ncommit\n  world <- [screen: \"game\" distance: 0 best: new]\n  player <- [x: 25 y: 50 velocity: 0]\n```\n\n## Drawing\n\n### Player\n\nNext we draw the `#player` at its (x,y) coordinates. Since the player is stationary in x, setting his x position here dynamically is just a formality, but it allows us to configure his position on the screen when we initialize. We create the sprite first, then set the x and y positions to let us reuse the same element regardless of where the player is.\n\nDraw the player\n\n```\nsearch @session @browser\n  svg = [#game-window]\n  player = [#player x y]\n\nbind @browser\n  sprite = [#image player | width: 10 height: 10 href: \"http://i.imgur.com/sp68LtM.gif\" sort: 8]\n  sprite.x := x - 5\n  sprite.y := y - 5\n  svg.children += sprite\n```\n\n### Obstacles\n\nDrawing obstacles is much the same process as drawing the player, but we encapsulate the sprites into a nested SVG to group and move them as a unit.\n\nDraw the obstacles\n\n```\nsearch @session @browser\n  svg = [#game-window]\n  obstacle = [#obstacle x height gap]\n  bottom-height = height + gap\n  imgs = \"https://cdn.rawgit.com/bhauman/flappy-bird-demo/master/resources/public/imgs\"\n\nbind @browser\n  sprite-group = [#svg #obs-spr obstacle sort: 2 overflow: \"visible\" children:\n    [#image y: 0 width: 10 height, preserveAspectRatio: \"none\" href: \"{{imgs}}/pillar-bkg.png\" sort: 1]\n    [#image x: -1 y: height - 5 width: 12 height: 5 href: \"{{imgs}}/lower-pillar-head.png\" sort: 2]\n    [#image y: bottom-height width: 10 height: 90 - bottom-height, preserveAspectRatio: \"none\" href: \"{{imgs}}/pillar-bkg.png\" sort: 1]\n    [#image x: -1 y: bottom-height width: 12 height: 5 href: \"{{imgs}}/lower-pillar-head.png\" sort: 2]]\n  sprite-group.x := x\n  svg.children += sprite-group\n```\n\n## Game Logic\n\nNow we need some logic to actually play the game. We slide obstacles along proportional to the distance travelled, and wrap them around to the beginning once they're entirely off screen. Additionally, we only show obstacles once their distance travelled is positive. This allows us to offset a pipe in the future, without the modulo operator wrapping it around to start off halfway through the screen.\n\n### Obstacles\n\nEvery 2 distance a wild obstacle appears\n\n```\nsearch\n  [#world distance]\n  obstacle = [#obstacle offset]\n  obstacle-distance = distance + offset\n  obstacle-distance >= 0\n\nbind\n  obstacle <- [x: 100 - (50 * mod[value: obstacle-distance, by: 2])]\n```\n\nWhen the obstacle is offscreen (`x > 90`), we randomly adjust the height of its gap to ensure the game doesn't play the same way twice. Eve's current random implementation yields a single result per seed per evaluation, so you can ask for `random[seed: \"foo\"]` in multiple queries and get the same result in that evaluation. In practice, this means that for every unique sample of randomness you care about in a program at a fixed time, you should use a unique seed. In this case, since we want one sample per obstacle, we just use the obstacle UUIDs as our seeds. The magic numbers in the equation just keep the gap from being at the very top of the screen or underground.\n\nReadjust the height of the gap every time the obstacle resets\n\n```\nsearch\n  [#world screen: \"game\" frame]\n  obstacle = [#obstacle x > 90]\n  height = random[seed: frame] * 30 + 5\n\ncommit\n  obstacle.height := height\n```\n\n### Flapping the player\n\nWhen a player clicks during gameplay, we give the bird some lift by setting its velocity.\n\n```\nsearch @event @session\n  [#click element: [#world]]\n  [#world screen: \"game\"]\n  player = [#player #self]\n\ncommit\n  player.velocity := 1.17\n```\n\n### Scroll the world\n\nNext, we scroll the world in time with frame updates. Eve is currently locked to 60fps updates here, but this will probably be configurable in the future. Importantly, we only want to update the world state once per frame, so to ensure that we note the offset of the frame we last computed in `world.frame` and ensure weâ€™re not recomputing for the same offset.\n\n```\nsearch @session @event\n  [#time frames]\n  world = [#world screen: \"game\" frame != frames gravity]\n  player = [#player y velocity]\n  not([#click])\n\ncommit\n  world.frame := frames\n  world.distance := world.distance + 1 / 60\n  player <- [y: y - velocity, velocity: velocity + gravity]\n```\n\n### Collision\n\nChecking collision with the ground is very simple. Since we know the y height of the ground, we just check if the player's bottom (determined by center + radius) is below that point.\n\nThe game is lost if the player hits the ground.\n\n```\nsearch\n  world = [#world screen: \"game\"]\n  [#player y > 85] // ground height + player radius\n\ncommit\n  world.screen := \"game over\"\n```\nCollision with the pipes is only slightly harder. Since they come in pairs, we first determine if the player is horizontally in a slice that may contain pipes and if so, whether we're above or below the gap. If neither, we're in the clear, otherwise we've collided.\n\nThe game is lost if the player hits an `#obstacle`\n\n```\nsearch\n  world = [#world screen: \"game\"]\n  [#player x y]\n  [#obstacle x: obstacle-x height gap]\n  âˆ‚x = abs[value: obstacle-x + 5 - x] - 10 // distance between the edges of player and obstacle (offset of 1/2 obstacle width because origin is on the left)\n  âˆ‚x < 0\n  collision = if y - 5 <= height then true\n              else if y + 5 >= gap + height then true\n\ncommit\n  world.screen := \"game over\"\n```\n\n[1]: https://github.com/bhauman/flappy-bird-demo\n","gaussian.eve":"# Plot a Gaussian Distribution\n\nThis program demonstrates event injection and drawing with SVGs.\n\nCreate an svg to draw into.\n\n```\nbind @browser\n  [#svg viewBox: \"0 0 50 2\", width: 200, height: 200]\n```\n\nRescale the svg area based on the maximum value in a histogram slot. Most browsers seem to also use this to rescale x to keep the aspect ratio constant.\n\n```\nsearch\n  [#slots x total]\n  m = max[value: total, given: total]\n\nsearch @browser\n  s = [#svg]\n\nbind @browser\n  s.viewBox := \"0 0 50 {{m + 2}}\"\n```\n\nFor each click, generate a gaussian sample, use floor to bin it into histogram by integer.\n\n```\nsearch @event @session\n  e = [#click]\n  x = floor[value: gaussian[seed: e, Ïƒ: 10, Î¼: 25]]\n  total = if [#slots x total] then total + 1 else 1\n\ncommit\n  s = [#slots x]\n  s.total := total\n```\n\nDraw the bins as black rectangles.\n\n```\nsearch\n  [#slots x total]\n  m = max[value: total, given: total]\n\nsearch @browser\n  s = [#svg]\n\ncommit @browser\n  k = [#rect x width: 1, stroke-width: 1, stroke: \"black\"]\n  k.y := m - total\n  k.height := total\n  s.children += k\n```\n\nInject a click once for each 1/60s.\n\n```\nsearch\n   [#time frames]\n\nbind @event\n   [#click frames]\n```\n","http.eve":"# HTTP Requests\n\nThis is a simple example that sends an HTTP request to a website. The website  returns a JSON result contains a list of users and some info about them. We parse those results and format them for display.\n\nDraw a button, that when clicked will send the HTTP request\n\n```\nbind @browser\n  [#button style: [height: 40], text: \"Send an HTTP Request\"]\n```\n\n## Send a request\n\nOn click, send the HTTP request. We're sending it to a service that sends back dummy data in a JSON format. We're expecting a list of users and some data about them.\n\n```\nsearch @event @browser @session\n  [#click element: [#button]]\n\ncommit @http\n  [#request #test-data url: \"https://jsonplaceholder.typicode.com/users/\"]\n```\n\nDisplay a message while the request is awaiting a response. If you're on a fast connection, you probably won't even see this message. Try disabling your wifi and sending a request, and you'll see this message displayed.\n\n```\nsearch @http\n  r = [#request not(response)]\n  total = count[given: r]\n\nbind @browser\n  [#div text: \"Requests in flight: {{total}}\"]\n```\n\n## Parse a response\n\nWe get back a list of users with the following JSON structure:\n\n`{ id, username, email, address: { street, suite, city, zipcode, geo: { lat, lng }}, phone, website, company: { name, catchPhrase, bs }}`\n\nWe're only going to display a couple of the attributes, so we can take only the ones we care about. Order doesn't matter\n\n```\nsearch @http\n  [#request #test-data response: [json]]\n  json = [#array]\n  lookup[record: json, attribute, value: [id name email phone website address: [street suite city zipcode]]]\n\ncommit\n  [#user id name email phone website address: [street suite city zip: zipcode]]\n```\n\nDisplay the responses in a formatted list. \n\n```\nsearch\n  [#user id name email address phone website]\n\nbind @browser\n  [#div text: \"Results: {{count[given: id]}}\"] \n  [#div sort: id, children: \n    [#h3 text: \"{{id}}: {{name}}\"]\n    [#div text: \"e-mail: {{email}}\"]\n    [#div text: \"phone: {{phone}}\"]\n    [#div text: \"website:\" children: \n      [#a href: website, text: website]]\n    [#div text: \"address: {{address.street}}, {{address.city}} {{address.zip}}\"]]  \n```\n","inspector.eve":"# Inspector\n\nThe inspector (\"don't panic\" button) is Eve's interactive debugging tool. It acts as a go between to help the Analyzer understand what's wrong based on your input. It handles the subset of issues that Eve can't know about a priori, where the program is valid and reasonable but not behaving as you intend; e.g.:\n\n- *\"I shouldn't be able to see this button when I'm not logged in.\"*\n- *\"The student attendance list is missing.\"*\n- *\"Too many emails were sent to each client.\"*\n- *\"The clock hand in the wrong position.\"*\n- *\"This program slow.\"*\n\nOnce Eve understands what the issue is, it provides a set of structured questions to work backwards through the symptoms to the source. Just telling you \"the block labelled 'draw a sign out button when logged in' drew the sign out button\" is worse than useless. However, with a little help from you (\"that user shouldn't have the tag `#logged-in` right now), Eve can work backwards and say \"the `#logged-in` tag was never removed from the user because she did not have an email attribute.\n\nWhen you've arrived at the root of the problem, the inspector provides tools to figure out why it happened. If, instead a missing attribute, the issue involved incorrect values (perhaps the result of mathematical error), Eve can show you intermediates to find where the breakdown occurs. When too many or too few rows match a pattern, Eve can show you the cardinality of the actions in a block to get a sense of why the numbers don't add up. Some issues the inspector can help diagnose can be found in  the **Example Scenarios** section.\n\n\n## Events\n\nClean the events we care about up.\n\n```\nsearch @event\n  event = if e = [#inspector #inspect] then e\n          if e = [#inspector #clear] then e\n\ncommit @event\n  event := none\n```\n\n### Inspect\n\nWhen the inspect event comes in, open a new inspector targeted to the inspected element/record/span.\n\nIf an inspector is already open, close it and nuke its state.\n\n```\nsearch @event\n  [#inspector #inspect]\n\nsearch @inspector\n  inspector = [#inspector]\n\nbind @event\n  [#inspector #clear inspector]\n```\n\nWhen an element is targeted, inspect it.\n\n```\nsearch @event\n  event = [#inspector #inspect #direct-target target: element type: \"element\" x y]\n\n\ncommit @inspector\n  [#inspector element state: (\"popout\", \"annotate-blocks\") | x y]\n\ncommit @event\n  event := none\n```\n\nWhen the document root is targeted, inspect it.\n\n```\nsearch @event\n  event = [#inspector #inspect #direct-target type: \"root\" x y]\n\n\ncommit @inspector\n  [#inspector root: \"true\" state: \"popout\" | x y]\n\ncommit @event\n  event := none\n```\n\nWhen a block is targeted, inspect it.\n\n```\nsearch @event\n  event = [#inspector #inspect target: block type: \"code_block\" x y]\n\ncommit @inspector\n  [#inspector block state: (\"block-popout\") | x y]\n\ncommit @event\n  event := none\n```\n\n### Focus/Unfocus Current\n\nWhen inspecting, the navigator will reveal a button which can be clicked to elide everything but the annotated sections of the document.\n\n```\nsearch @event\n  event = [#inspector #focus-current]\n\nsearch @inspector\n  inspector = [#inspector state]\n  focus-states = if state = \"annotate-blocks\" then \"focus-blocks\"\n                 if state = \"annotate-affectors\" then \"focus-affectors\"\n                 if state = \"annotate-failures\" then \"focus-failures\"\n                 if state = \"annotate-performance\" then \"focus-performance\"\n\ncommit @inspector\n  inspector.state += focus-states\n\ncommit @event\n  event := none\n```\n\n```\nsearch @event\n  event = [#inspector #unfocus-current]\n\nsearch @inspector\n  inspector = [#inspector state]\n  focus-states = if state = \"annotate-blocks\" then \"focus-blocks\"\n                 if state = \"annotate-affectors\" then \"focus-affectors\"\n                 if state = \"annotate-failures\" then \"focus-failures\"\n                 if state = \"annotate-performance\" then \"focus-performance\"\n\ncommit @inspector\n  inspector.state -= focus-states\n\ncommit @event\n  event := none\n```\n\n### Clear\n\nWhen an inspector clear event comes in, remove open inspectors and all their state.\n\n```\nsearch @event @inspector\n  event = [#inspector #clear]\n  inspector = if event.inspector then event.inspector\n              else [#inspector]\n\ncommit @inspector\n  inspector := none\n  inspector.state := none\n  inspector.data := none\n```\n\n### Click Option\n\nWhen an inspector button is pressed, activate any new states we want to transition into.\n\n```\nsearch @event\n  [#click #direct-target element]\n\nsearch @browser\n  element = [#button inspector activate]\n\ncommit @inspector\n  inspector.state += activate\n```\n\nWhen an inspector button is pressed, deactivate any old states we may have been in that want to leave.\n\n```\nsearch @event\n  [#click #direct-target element]\n\nsearch @browser\n  element = [#button inspector deactivate]\n\ncommit @inspector\n  inspector.state -= deactivate\n```\n\n### Click Attribute Table\n\nWhen a row in the attribute table is clicked, find the source of that particular attribute.\n\n```\nsearch @event\n  [#click element]\n  // If we're clicking on an entity value, we'll handle that elsewhere\n  [#click element: value-elem]\n\nsearch @browser\n  not(value-elem = [#value is-entity: true])\n\n  element = [#kv-row key]\n  [#kv-table inspector children: element]\n\ncommit @inspector\n  inspector.attribute := key\n```\n\nWhen we click a value in the attribute table, if it's an entity navigate to it.\n\n```\nsearch @event\n  [#click element]\n  [#click element: value-elem]\n\nsearch @browser\n  value-elem = [#value is-entity: true text: entity]\n\n  element = [#kv-row key]\n  [#kv-table inspector children: element]\n\nsearch @inspector\n  x = inspector.x\n  y = inspector.y\n\nbind @event\n  [#inspector #inspect #direct-target target: entity type: \"element\" x y]\n```\n\n### Click Elsewhere\n\nAny click that is entirely outside of the inspector will close it.\n\n```\nsearch @inspector\n  inspector = [#inspector]\n\nsearch @event\n  event = [#click]\n  not([#click element: inspector])\n\ncommit @inspector\n  inspector := none\n```\n\nWhile the inspector is open on an element, update its avs to that element's avs. This will persist until it's no longer potentially relevant.\n@NOTE: This is kind of weird and it may be better to have multiple targets instead.\n\n```\nsearch @inspector\n  inspector = [#inspector element]\n\nsearch @browser\n  lookup[record: element, attribute, value]\n\ncommit @inspector\n  inspector.avs := [attribute value]\n```\n\n## Data\n\nAs the inspector states change, it will need to gather different data from the editor and language service. Data requests will be added to the `data` attribute and requests for that data will be bound for so long as those values exist. By gathering all the data in a separate pass, UI to display it can share the same data and be written immediate-mode style.\n\nCertain kinds of data depend on other data.\n\n```\ncommit @inspector\n  [#data data: \"sources\"]\n  [#data data: \"source-sections\", requires: \"sources\"]\n  [#data data: \"related\" requires: \"sources\"]\n  [#data data: \"cardinalities\" requires: \"related\"]\n  [#data data: \"values\" requires: \"related\"]\n  [#data data: \"all-values\" requires: \"related\"]\n  [#data data: \"affectors\"]\n  [#data data: \"affector-failures\" requires: \"affectors\"]\n  [#data data: \"performance-stats\"]\n```\n\nIf we need data that has a dependency, make sure we're fetching that too.\n\n```\nsearch @inspector\n  inspector = [#inspector data]\n  [#data data requires]\n\nbind @inspector\n  inspector.data += requires\n```\n\n### Sources\n\nFind source(s) for the current record.\n\n```\nsearch @inspector\n  [#inspector data: \"sources\" element: record not(attribute)]\n\nbind @editor\n  [#find-source record]\n```\n\nFind source(s) for a specific attribute of the current record.\n\n```\nsearch @inspector\n  [#inspector data: \"sources\" element: record attribute]\n\nbind @editor\n  [#find-source record attribute]\n```\n\n### Source Sections\n\nFind the section(s) containing the found source(s).\n\n```\nsearch @inspector\n  [#inspector data: \"source-sections\" element: record]\n\nsearch @editor\n  [#source record block]\n\nbind @editor\n  [#find-section span: block]\n```\n\n### Related\n\nFind related(s) for the current record's source action(s).\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"related\" element: record]\n\nsearch @editor\n  [#source record span]\n\nbind @editor\n  [#find-related inspector | span]\n```\n\n### Values\n\nFind the intermediate values that contribute to the currently targeted record.\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"values\" element avs: [attribute value]]\n\nsearch @editor\n  [#source record: element block span]\n  [#related span variable]\n\nbind @editor\n  [#find-value inspector | variable given: [attribute value]]\n```\n\n### All Values\n\nFind all intermediate values for the current target's related variable(s).\n\n```\nsearch @inspector\n  (inspector, element) = if i = [#inspector data: \"all-values\" element] then (i, element)\n                        else if i = [#inspector data: \"values\" element not(avs)] then (i, element)\n\nsearch @editor\n  [#source record: element block span]\n  [#related span variable]\n\nbind @editor\n  [#find-value inspector | variable]\n```\n\n### Cardinalities\n\nFind cardinalities for the current target's related variable(s).\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"cardinalities\" element]\n\nsearch @editor\n  [#source record: element block span]\n  [#related span variable]\n\nbind @editor\n  [#find-cardinality inspector | variable]\n```\n\n### Affectors\n\nFind the set of blocks that could affect the currently targeted element.\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"affectors\" element]\n\nbind @editor\n  [#find-affector record: element attribute: \"children\"]\n```\n\nFind the set of blocks that could draw into the document root\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"affectors\" root]\n\nbind @editor\n  [#find-root-drawers]\n```\n\n### Affector Failures\n\nFind the reasons why affectors of the current target failed.\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"affector-failures\" element]\n\nsearch @editor\n  [#affector record: element block]\n\nbind @editor\n  [#find-failure block]\n```\n\n### Block Failure\n\nFind the reason why the targeted block failed.\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"block-failure\" block]\n\nbind @editor\n  [#find-failure block]\n```\n\n### Performance Stats\n\n```\nsearch @inspector\n  inspector = [#inspector data: \"performance-stats\"]\n\nbind @editor\n  [#find-performance]\n```\n\n## States\n\nInspector states control how the inspector interacts with the editor and presents itself to the user.\n\nCertain states require data to be fetched.\n\n```\ncommit @inspector\n  // Element States\n  [#state state: \"focus-blocks\" requires: \"sources\"]\n  [#state state: \"annotate-blocks\" requires: \"sources\"]\n  [#state state: \"highlight-related\" requires: \"related\"]\n  [#state state: \"show-values-inline\" requires: \"values\"]\n  [#state state: \"show-values-table\" requires: \"values\"]\n  [#state state: \"show-cardinalities-inline\" requires: \"cardinalities\"]\n  [#state state: \"focus-affectors\" requires: \"affectors\"]\n  [#state state: \"annotate-affectors\" requires: \"affectors\"]\n  [#state state: \"focus-failures\" requires: \"affector-failures\"]\n  [#state state: \"annotate-failures\" requires: \"affector-failures\"]\n  [#state state: \"highlight-failures\" requires: \"affector-failures\"]\n\n  // Block States\n  [#state state: \"highlight-block-failure\" requires: \"block-failure\"]\n  [#state state: \"annotate-performance\" requires: \"performance-stats\"]\n  [#state state: \"focus-performance\" requires: \"performance-stats\"]\n```\n\nWhen the inspector is in a state that requires data, request that data.\n\n```\nsearch @inspector\n  [#state state requires]\n  inspector = [#inspector state]\n\nbind @inspector\n  inspector.data += requires\n```\n\n### Focus Blocks\n\nWhen the `\"focus-blocks\"` state is active, elide everything but the originating blocks for the current target.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"focus-blocks\" element]\n\nsearch @editor\n  [#source record: element block]\n\nbind @editor\n  [#elide-between-sections inspector | span: block]\n  [#jump-to position: 0]\n```\n\n### Annotate Blocks\n\nWhen the `\"annotate-blocks\"` state is active, annotate each source block for the current target.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"annotate-blocks\" element]\n\nsearch @editor\n  [#source record: element block]\n\nbind @editor\n  [#mark-span inspector type: \"block_annotation\" span: block kind: \"source\" message: \"This block provides the inspected value.\"]\n  [#jump-to span: block]\n```\n\n### Highlight Related\n\nWhen the `\"highlight-related\"` state is active, mark all related spans highlighted.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"highlight-related\" element]\n\nsearch @editor\n  [#source record: element span]\n  [#related span variable]\n\nbind @editor\n  [#mark-span inspector type: \"highlight\" | span: variable]\n```\n\n### Show Values Inline\n\nWhen the `\"show-values-inline\"` state is active, badge any found intermediate values.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"show-values-inline\" element]\n\nsearch @editor\n  [#source record: element block span]\n  [#related span variable]\n  [#value variable value row: 1]\n\nbind @editor\n  [#mark-span inspector type: \"badge\" kind: \"intermediate\" target: element message: value span: variable]\n```\n\n### Show Values Table\n\nWhen the `\"show-values-table\"` state is active, embed a table of found intermediate values.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"show-values-table\" element]\n\nsearch @editor\n  [#source record: element block span]\n  [#related span variable]\n  [#value variable value row name]\n\nbind @view\n  row-guy = [row]\n  lookup[record: row-guy attribute: name value]\n  table = [#table inspector | field: name row: row-guy]\n\nbind @browser\n  table.span := block\n```\n\n### Show Cardinalities Inline\n\nWhen the `\"show-cardinalities-inline\"` state is active, badge any found cardinalities.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"show-cardinalities-inline\" element]\n\nsearch @editor\n  [#source record: element block span]\n  [#related span variable]\n  [#cardinality variable cardinality]\n\nbind @editor\n  [#mark-span inspector type: \"badge\" kind: \"cardinality\" target: element message: cardinality | span: variable]\n```\n\n### Focus Affectors\n\nWhen the `\"focus-affectors\"` state is active, elide everything but the blocks which could impact the target.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"focus-affectors\" element]\n\nsearch @editor\n  [#affector record: element block action]\n\nbind @editor\n  [#elide-between-sections inspector | span: block]\n  [#jump-to position: 0]\n  [#mark-span inspector type: \"highlight\" | span: action]\n```\n\n### Annotate Affectors\n\nWhen the `\"annotate-affectors\"` state is active, annotate blocks which could impact the target element.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"annotate-affectors\" element]\n\nsearch @editor\n  [#affector record: element block action]\n\nbind @editor\n  [#mark-span inspector type: \"block_annotation\" span: block kind: \"affector\" message: \"This block affects the inspected value.\"]\n  [#jump-to span: block]\n```\n\nWhen the `\"annotate-affectors\"` state is active, annotate blocks which could draw to the document root.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"annotate-affectors\" root]\n\nsearch @editor\n  [#root-drawer span start stop]\n\nbind @editor\n  [#mark-range inspector type: \"annotation\" span start stop kind: \"affector\" message: \"This block could draw to the document root.\"]\n  [#jump-to position: start]\n```\n\n### Focus Failures\n\nWhen the `\"focus-failures\"` state is active, elide everything but the blocks which could impact the target but did not.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"focus-failures\" element]\n\nsearch @editor\n  [#affector record: element block action]\n  [#failure block]\n\nbind @editor\n  [#elide-between-sections inspector | span: block]\n  [#jump-to position: 0]\n  [#mark-span inspector type: \"highlight\" | span: action]\n```\n\n### Annotate Failures\n\nWhen the `\"annotate-failures\"` state is active, annotate the blocks which could impact the target.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"annotate-failures\" element]\n\nsearch @editor\n  [#affector record: element block action]\n  [#failure block]\n\nbind @editor\n  [#mark-span inspector type: \"block_annotation\" span: block kind: \"failure\" message: \"This block could affect the inspected value but failed.\"]\n  [#jump-to span: block]\n```\n\n### Highlight Failures\n\nWhen the `\"highlight-failures\"` state is active, show the failing reasons for blocks that impact the target.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"highlight-failures\" element]\n\nsearch @editor\n  [#affector record: element block]\n  [#failure block start stop]\n\nbind @editor\n  [#mark-range type: \"cause-of-failure\" start stop]\n```\n\n### Highlight Block Failure\n\nWhen the `\"highlight-block-failure\"` state is active, show the failing reason for the targeted block.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"highlight-block-failure\" block]\n\nsearch @editor\n  [#failure block start stop]\n\nbind @editor\n  [#mark-range type: \"cause-of-failure\" start stop]\n```\n\n### Annotate Performance\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"annotate-performance\"]\n\nsearch @editor\n  [#performance block color]\n  color != \"green\"\n\nbind @editor\n  [#mark-span inspector type: \"block_annotation\" span: block kind: \"performance-{{color}}\" message: \"This block has performance issues.\"]\n```\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"annotate-performance\"]\n\nsearch @editor\n  perf = [#performance block color]\n  total-percent = to-fixed[value: perf.percent, places: 2]\n  average-time = to-fixed[value: perf.average, places: 2]\n  max-time = to-fixed[value: perf.max, places: 2]\n\nbind @editor\n  [#mark-span inspector type: \"document_widget\" span: block kind: \"performance-{{color}}\" message: \"{{total-percent}}% of total | average {{average-time}}ms | max {{max-time}}ms\"]\n\n```\n\n### Focus Performance\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"focus-performance\"]\n\nsearch @editor\n  [#performance block color != \"green\"]\n\nbind @editor\n  [#elide-between-sections inspector | span: block]\n  [#jump-to position: 0]\n```\n\n## Drawing\n\nWhile we have an inspector, notify the editor about its existence.\n\n```\nsearch @inspector\n  inspector = [#inspector x y]\n\nbind @browser\n  inspector <- [#editor #inspector x y: y + 15]\n```\n\nWhen an `#inspector` is open targeted to an element, show the element popout.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"popout\" element]\n\nbind (@view, @browser)\n  attributes = [#attribute-table inspector entity: element]\n\nbind @browser\n  inspector <-\n    [#div element class: \"inspector-pane\" children:\n      [#div #attributes-panel inspector children: attributes]\n      [#div #options-panel inspector class: \"buttons\" children:\n        [#button inspector text: \"Find events\" activate: \"focus-blocks\", deactivate: \"popout\"]\n        [#button inspector text: \"Why this?\" activate: \"show-values-table\" deactivate: \"popout\"]\n        [#button inspector text: \"Too few? Too many?\" activate: \"show-cardinalities-inline\" deactivate: \"popout\"]\n        [#button inspector text: \"Not drawing?\" activate: (\"annotate-affectors\", \"highlight-failures\") deactivate: (\"annotate-blocks\", \"popout\")]]]\n```\n\nWhen an `#inspector` is open targeted to the document root, show the root popout.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"popout\" root]\n\nbind @browser\n  inspector <- [#div class: \"inspector-pane\" children:\n      [#div #options-panel inspector class: \"buttons\" children:\n        [#button inspector text: \"Not drawing?\" activate: (\"annotate-affectors\", \"highlight-failures\") deactivate: \"popout\"]]]\n```\n\nWhen an `#inspector` is open targeted to a block, show the block popout.\n@TODO: Just make this the popout for blocks.\n\n```\nsearch @inspector\n  inspector = [#inspector state: \"block-popout\" block]\n\nbind @browser\n  inspector <- [#div in-editor: true class: \"inspector-pane\" children:\n    [#div #options-panel inspector class: \"buttons\" children:\n    [#button inspector text: \"Did this fail?\" activate: \"highlight-block-failure\" deactivate: \"block-popout\"]\n    [#button inspector text: \"Why is this slow?\" activate: \"annotate-performance\" deactivate: \"block-popout\"]]]\n\n```\n\n## Debug\n\n### Inspector Debugger\n\n```\nsearch @view\n  wrapper = [#inspector-debugger inspector]\n  lookup[record: wrapper, attribute: \"tag\", value: \"inspector-debugger\", node]\n\nsearch (@session, @browser, @inspector)\n  lookup[record: inspector attribute: key value]\n\nbind @view @browser\n  wrapper.node := node\n  wrapper.tag += \"kv-table\"\n  wrapper.kvs := [key value]\n```\n\n\n\n## Example Scenarios\n\n### Missing Attribute\n\n*\"I shouldn't be able to see this button when I'm not logged in.\"*\n\n1. Click the investigate button.\n2. Click the logout button.\n  - Should this not show up right now?\n  - Are there too many or few of these?\n  - Does this have an incorrect value?\n    - List of attributes\n3. This should not show up right now.\n  - Filter code to blocks which create the logout button.\n  - Show a timeline of events creating the button.\n    - The `[#button #log-out]` is drawn because `app.user` is tagged `#logged-in`.\n    - The `app.user` is tagged `#logged-in` because the `[#button #login]` was clicked.\n  - List blocks which could cause it to stop drawing.\n    - The `app.user` `#logged-in` tag was not removed when `[#button #logout]` was clicked because `app.user` did not have an `email` attribute.\n\n### Bad Join\n\n*\"The student attendance list is missing.\"*\n\n1. Click the investigate button.\n2. Click where the attendance list belongs.\n  - Qs\n3. This should contain something.\n  - Filter code to blocks which can create children for this element.\n  - Highlight the bailing reason for each block.\n  - Summary\n    - [this block](#) can insert here, but `[#app page: not(grades)]`\n    - [this block](#) can insert here, but `[#app page: not(syllabus)]`\n    - [this block](#) can insert here, but `teacher.students` is empty\n4. Click `teacher.students`\n  - Filter code to the blocks affecting `teacher.students`\n    - [this block](#) creates `teacher.students`, but `not(student.name = school.name)`\n\n\n### Wrong Cardinality\n\n*\"Too many emails were sent to each client.\"*\n\n1. Click the investigate button.\n2. Click an email to a client.\n  - Should this not show up right now?\n  - Are there too many or few of these?\n  - Does this have an incorrect value?\n    - List of attributes\n3. There are too many of these.\n  - Filter code to the block which created the emails.\n  - Gray out the patterns that do not contribute to the cardinality of the emails.\n  - Embed a cardinality badge for each relevant pattern.\n  - Summary\n    - an email was created for each `[#client email]` (721) X `[#promo message]` (1) X `[#admin email]` (5).\n  - Click a pattern to see its values.\n4. Click `[#admin email]`.\n  - There are 5 `[#admin]`s, each with one `email`. These are: ...\n\n### Wrong Value\n\n*\"The clock hand in the wrong position.\"*\n\n1. Click the investigate button.\n2. Click the clock hand.\n  - Should this not show up right now?\n  - Are there too many or few of these?\n  - Does this have an incorrect value?\n    - List of attributes\n3. Click the `x2` attribute.\n  - Filter code to the blocks affecting the `x2` attribute of the entity.\n  - Gray out the patterns that do not contribute to the `x2` attribute.\n  - Embed value badges for each relevant variable.\n  - Summary\n    - `[#clock-hand angle` (70) `length` (30) `]`.\n    - `x2` (78.19) `= 50 + (length` (30) `* sin[angle` (70) `]` (0.94) `)`.\n    - `hand <- [#line x1: 50, y1: 50, x2` (78.19) `y2]`.\n4. Click the `angle` attribute.\n  - Filter code to the blocks affecting the `angle` attribute of the `[#clock-hand]`\n  - Gray out the patterns that do not contribute to the `angle attribute`.\n  - Embed value badges for each relevant variable.\n  - Summary\n    - `[#clock-hand #hour-hand angle` (900)`: 60 * hours` (15) `, length: 30, stroke: \"#023963\"]`\n\n### Performance\n\n*\"This program slow.\"*\n\n1. Click the investigate button.\n2. ???\n3. Color-code blocks by total time spent.\n4. Click a block.\n  - Display total percentage of time spent.\n  - Display total number of rows run.\n  - Display average/max/min time per row.\n\n### Exploration\n\n*\"What has this block done?\"*\n1. Click the investigate button.\n2. Click the block\n  - What does this depend on?\n  - What does this create?\n  - What depends on this?\n3. What does this create?\n  - List patterns and cardinalities created by this node\n  - Highlight visible side effects (e.g. ui)\n\n*\"What created this?\"*\n1. Click the investigate button.\n2. Click the element or pattern\n  - What created this?\n3. What created this?\n  - Filter code to blocks affecting this.\n  - Highlight the specific actions impacting this.\n\n\n## Inspector views\n\n- Element\n- Variable\n- Action\n- Scan\n- Block\n\n- Active element\n  - Something's wrong\n    - Are there too many/few of these?\n    - Is a value wrong?\n    - Is something missing?\n    - Should this not be here? (?)\n  - Exploration\n    - source\n    - dependents\n\n- Active variable\n  - Something's wrong\n    - Are there too many/few of these?\n","pet-lengths.eve":"# Pet Lengths\n\nDemonstration of the bar graph view.\n\nCreate some pets with rigorously measured lengths.\n\n```\ncommit\n  [#pet name: \"koala\" length: 7]\n  [#pet name: \"cat\" length: 3]\n  [#pet name: \"whale\" length: 12]\n  [#pet name: \"dog\" length: 14]\n  [#pet name: \"orangutan\" length: 9]\n  [#pet name: \"lemur\" length: 5]\n```\n\nEach pet is a single bar on our graph. The bar's label is the pet's name, it's height is the pet's length. The sort property tells the bar graph to draw the bar in alphabetical order based on the pets' names.\n\n```\nsearch\n  [#pet name length]\n  ix = sort[value: name]\n\nbind @view\n  [#bar-graph | bar: [label: name height: length sort: ix]]\n```\n\nA team of scientists work tirelessly around the clock to keep the mysterious whargarbbl's length updated. Since each bar in the bar chart is bound above, the whargarbbl's bar will stay in sync.\n\n```\nsearch\n  [#time minutes seconds]\n  length = random[seed: minutes * seconds] * 30\n\nbind\n  [#pet name: \"whargarbbl\" length]\n```\n","quickstart.eve":"# Eve Quick Start Tutorial\n\n```eve\nbind @browser\n  [tag: \"div\", text: \"Hello, world\"]\n```\n\nHello world! At its core, Eve is a pattern matching language. You match patterns of data by searching a database, then update or create new data according to what you've found. In this example, we created a [record][records] that has two attributes: a tag attribute with the value `\"div\"`, and a text attribute with the value `\"Hello, world\"`. We [bound][bind] this record to the browser, which is how we displayed our venerable message.\n\nEve code is fenced off in blocks, which can be written in any order and embedded in Markdown documents. This is how Eve programs are written: everything in a code fence is a [block][blocks] of Eve code, while everything outside is prose describing the program. In fact, this quick start tutorial is an example of an executable Eve program! In the subsequent blocks, you won't see any code fences, but they still exist in the [document's source][quickstart-source]. You may have noticed the checkbox in the top right corner of the code block. In Eve, any block can be disabled in one click. As you work through the quickstart, enable each block you reach to follow along.\n\nSo far we've created a record that displays \"Hello, world!\" but as I said, Eve is a pattern matching language. Let's explore that by searching for something:\n\n```eve disabled\nsearch\n  [name]\n\nbind @browser\n  [tag: \"div\", text: \"Ciao, world\"]\n```\n\nOur message never appeared! Before, we bound without searching, so the message displayed by default. Now we're binding in the presence of a [search][search] action, so the bound record only exists if all the searched records are matched. Here, we're searching for all records with a `name` attribute, but we haven't added any records like that to Eve; so none are matched. With no matching records, the `bind` cannot execute, and the message disappears from the screen.\n\nThis is the flow of an Eve block: you search for records in a database, and if all the records you searched for are matched, you can modify the matched records or create new ones. If any part of your search is not matched, then no records will be created or updated.\n\nTo get our new message to show up, all we need is a record with a name attribute. We can create one permanently with the [commit][commit] action:\n\n```eve disabled\ncommit\n  [name: \"Celia\"]\n```\n\nHello, worldâ€¦ again! Commit permanently updates or creates a record that will persist even if its matched records (the records matched in a search action) change. Since we aren't searching for anything in this block, the commit executes by default and adds a record with a name attribute of `\"Celia\"`. The addition of this new record satisfies the search in the previous block, so \"Ciao, world!\" appears on the screen along with the first message.\n\nBut what else can you do with matched records? For starters, we can use them to create more records:\n\n```eve disabled\nsearch\n  [name]\n\nbind @browser\n  [#div, text: \"Hello, {{name}}\"]\n```\n\nSince we matched on a record with a name attribute, we now have a reference to that name, and we can inject it into a string using [{{ ... }}][string-interpolation] embedding. Since tags are used so commonly in Eve, we can swap out `tag: \"div\"` for its syntax-sugared form `#div`. [Tags][tags] are often used to talk about groups of related records. For example, we could search for all records with a `#student` tag, with name, grade, and school attributes.\n\n```eve disabled\nsearch\n  [#student name grade school]\n\nbind @browser\n  [#div text: \"{{name}} is a {{grade}}th grade student at {{school}}.\"]\n```\n\nSince we're matching on more attributes, this block is no longer satisfied by the record we added earlier. We're missing a `#student` tag, as well as grade and school attributes. Even though these are currently missing, we can still write the code that would display them as if they existed.\n\nLet's display this new message by adding the missing attributes to Celia. We could add them to the block where we comitted Celia originally, but we can also do it programatically:\n\n```eve disabled\nsearch\n  celia = [name: \"Celia\"]\n\nbind\n  celia <- [#student grade: 10, school: \"East\", age: 16]\n```\n\nYou can define variables within blocks, which act as handles on records that allow you to change them. In this case, we're using the [merge operator][merge] `<-` to combine two records. With the addition of this block, the sentence \"Celia is a 10th grade student at East.\" appears in the browser.\n\nCelia is cool and all, but let's add a few more students to our database:\n\n```eve disabled\ncommit\n  [#student name: \"Diedra\", grade: 12, school: \"West\"]\n  [#student name: \"Michelle\", grade: 11, school: \"West\"]\n  [#student name: \"Jermaine\", grade: 9]\n```\n\nThree sentences are now printed, one for each student that matches the search. Eve works on [sets][sets], so when we search for `[#student name grade school]`, we find _all_ records that match the given pattern. This includes Celia, Diedra and Michelle (but not Jermaine, as he has no school in his record). Therefore, when we bind the record `[#div text: \"{{name}} is a ... \"]`, we are actually binding three records, one for each matching `#student`.\n\nIf you re-compile the program a couple times, you'll see the order of sentences may change. This is because **there is no ordering in Eve - blocks are not ordered, statements are not ordered, and results are not ordered**. If you want to order elements, you must impose an ordering yourself. We can ask the browser to draw elements in an order with the \"sort\" attribute:\n\n```eve disabled\nsearch\n  [#student name grade school]\n\nbind @browser\n  [#div sort: name, text: \"{{name}} is a {{grade}}th grade student at {{school}}.\"]\n```\n\nThis time when you recompile your program, the order will stay fixed, sorted alphabetically by name.\n\nLet's make things a little more interesting by adding some records about the schools the students attend:\n\n```eve disabled\ncommit\n  [#school name: \"West\", address: \"1234 Main Street\"]\n  [#school name: \"East\", address: \"5678 Broad Street\"]\n```\n\nWhat if we want to display the address of the school each student attends? Although `#student`s and `#school`s are in different records, **we can relate two records by associating attributes from one record with attributes from the other.** This is an operation known as [joining][joins]. In this case, we want to relate the `name` attribute on `#schools` with the `school` attribute on `#students`. This compares the values of the attributes between records, and matches up those with the same value. For instance, since Celia's school is \"East\", she can join with the `#school` named \"East\".\n\nOur first attempt may come out looking a little something like this:\n\n```eve disabled\nsearch\n  school = [#school name address]\n  student = [#student name school: name]\n\nbind @browser\n  [#div text: \"{{student.name}} attends {{school.name}} at {{address}}\"]\n```\n\nBut that didn't work. How come? In Eve, **things with the same name are [equivalent][equivalence]**. In this block, we've used \"name\" three times, which says that the school's name, the student's name, and the student's school are all the same. Of course, there is no combination of students and schools that match this search, so nothing is displayed.\n\nInstead, we can use the dot operator to specifically ask for the name attribute in the `#school` records, and rename our variables to get a correct block:\n\n```eve disabled\nsearch\n  schools = [#school address]\n  students = [#student school: schools.name]\n\nbind @browser\n  [#div text: \"{{students.name}} attends {{schools.name}} at {{address}}\"]\n```\n\nThis creates an implicit join over the school name without mixing up the names of the students and the names of the schools, giving us our desired output. You can actually bind attributes to any name you want to avoid collisions in a block:\n\n```eve disabled\nsearch\n  [#school name: school-name address]\n  [#student name: student-name school: school-name]\n\nbind @browser\n  [#div text: \"{{student-name}} attends {{school-name}} at {{address}}\"]\n```\n\n## Advanced Eve\n\nRecall when we added our students, Celia was the only one we added an `age` to. Therefore, the following block only displays Celia's age, even though we ask for all the `#student`s:\n\n```eve disabled\nsearch\n  [#student name age]\n\nbind @browser\n  [#div text: \"{{name}} is {{age}} years old\"]\n```\n\nLet's pretend that all students enter first grade at six years old. Therefore, if we know a student's grade, we can calculate their age and add it to the student's record:\n\n```eve disabled\nsearch\n  student = [#student]\n  calculated-age = if student.age then student.age\n                   else if student.grade then student.grade + 5\n\nbind\n  student.age := calculated-age\n```\n\nThis block selects all students, and uses and [if-then][if-then] expression to set the student's calculated age. If the student already has an age, we set it to that. Otherwise, if the student has no age, we can calculate it with some arithmetic. The [set operator][set] `:=` sets an attribute to a specified value regardless of what it was before the block executed. That value can be anything, from a number to a string to another record.\n\n### Aggregates\n\nSo far everything we've done has used one record at a time, but what happens when we want to work over a group of records, such as counting how many students there are? To solve such a problem, we'll need to use an [aggregate][aggregates]. Aggregates take a set of values and turn them into a single value, akin to \"fold\" or \"reduce\" functions in other languages. In this case, we'll use the aggregate [count][count] to figure out how many `#students` are in the school district:\n\n```eve disabled\nsearch\n  students = [#student]\n  total-students = count[given: students]\n\nbind @browser\n  [#div text: \"{{total-students}} are in the school district\"]\n```\n\nA quick note on the syntax for `count` - it feels a lot like a function in other languages, since it has a return value and can be used inline in expressions. Under the hood, [functions][functions] and aggregates are actually records; `total = count[given: students]` is shorthand for `[#count #function given: students, value: total]`. This distinction won't materially change the way you use `count`, but it goes to show that everything in Eve reduces to working with records.\n\nWhile `given` is a required argument in `count`, aggregates (and functions in general) can also have optional arguments. Let's say we want to know how many students attend each school. We can use the optional argument `per` to count students grouped by the school they attend:\n\n```eve disabled\nsearch\n  students = [#student school]\n  students-per-school = count[given: students, per: school]\n\nbind @browser\n  [#div text: \"{{students-per-school}} attend {{school}}\"]\n```\n\nAll function-like records in Eve specify their arguments as attributes. This means you specify the argument and its value, unlike in other languages, where the order of the values determines the attribute to which they belong. As with everything else in Eve, order doesn't matter.\n\n## Extra Credit\n\nAt this point, you know everything necessary about Eve to complete this extra credit portion (the only additional knowledge you need is domain knowledge of HTML and forms). Let's review some of the key concepts:\n\n- Eve programs are composed of blocks of code that search for and update records.\n- Records are sets of `attribute: value` pairs attached to a unique ID.\n- Eve works with sets, which have no ordering and contain unique elements.\n- Things with the same name are equivalent.\n\nYour extra credit task is to build a web-based form that allows you to add students to the database. Take a moment to think about how this might be done in Eve, given everything we've learned so far.\n\nFirst, let's make the form. We've already displayed a `#div`, and in the same way we can draw `#input`s and a `#button`:\n\n```eve disabled\nbind @browser\n  [#div children:\n    [#div sort: 1, text: \"Name:\"]\n    [#input #name-input sort: 2]\n    [#div sort: 3, text: \"Grade:\"]\n    [#input #grade-input sort: 4]\n    [#div sort: 5, text: \"School:\"]\n    [#input #school-input sort: 6]\n    [#button #submit sort: 7 text: \"submit\"]]\n```\n\nWe've added some tags to the inputs and the button to distinguish them, so we can easily search for them from other blocks. Now that we have a form, we need to define what happens when the submit button is clicked.\n\nRemember, everything in Eve is a record, so the `#click` event is no different. When a user clicks the mouse in the browser, Eve records that click in the database.\n\nThis record exists only for an instant, but we can react to it by searching for `[#click element: [#submit]]`. This record represents a `#click` on our `#submit` button. Then, all we need to do is capture the values of the input boxes and save them as a `#student` record:\n\n```eve disabled\nsearch @browser @event\n  [#click element: [#submit]]\n  name = [#name-input]\n  grade = [#grade-input]\n  school = [#school-input]\n  grade-number = convert[value: grade.value to: \"number\"]\n\ncommit\n  // save the new student\n  [#student name: name.value, grade: grade-number, school: school.value]\n\ncommit @browser\n  // reset the form\n  name.value := \"\"\n  grade.value := \"\"\n  school.value := \"\"\n```\n\n## Learning more\n\nIf you want to learn more about Eve, we have some resources to help with that:\n\n- Example applications - See some working programs and explore how they work.\n- Tutorials - Step by step instructions on building Eve applications.\n- [The Eve Handbook](https://witheve.github.io/docs) - Everything you need to know about Eve.\n- [Eve syntax reference](https://witheve.github.io/assets/docs/SyntaxReference.pdf) - Eve's syntax in one page.\n- Guides - In-depth documents on topics relating to Eve.\n\nWe also invite you to join the Eve community! There are several ways to get involved:\n\n- Join our [mailing list](https://groups.google.com/forum/#!forum/eve-talk) and get involved with the latest discussions on Eve.\n- Impact the future of Eve by getting involved with our [Request for Comments](https://github.com/witheve/rfcs) process.\n- Read our [development diary](http://incidentalcomplexity.com/) for the latest news and articles on Eve.\n- Follow us on [twitter](https://twitter.com/with_eve).\n\n\n[records]: https://witheve.github.io/docs/handbook/records/\n[blocks]: https://witheve.github.io/docs/handbook/blocks/\n[search]: https://witheve.github.io/docs/handbook/search/\n[bind]: https://witheve.github.io/docs/handbook/bind/\n[commit]: https://witheve.github.io/docs/handbook/commit/\n[string-interpolation]: https://witheve.github.io/docs/handbook/string-interpolation/\n[joins]: https://witheve.github.io/docs/handbook/joins/\n[quickstart-source]: https://github.com/witheve/Eve/blob/ts-merge/examples/quickstart.eve\n[tags]: https://witheve.github.io/docs/handbook/tags/\n[merge]: https://witheve.github.io/docs/handbook/merge/\n[sets]: https://witheve.github.io/docs/handbook/sets/\n[equivalence]: https://witheve.github.io/docs/handbook/equivalence/\n[if-then]: https://witheve.github.io/docs/handbook/if-then/\n[set]: https://witheve.github.io/docs/handbook/set/\n[aggregates]: https://witheve.github.io/docs/handbook/aggregates/\n[functions]: https://witheve.github.io/docs/handbook/functions/\n[count]: https://witheve.github.io/docs/handbook/statistics/count/\n","server.eve":"dude\n\n```\n  search @server\n    r = [#request url headers: [user-agent]]\n  commit @server\n    r.response := [#response status: 200, body: \"yo!\"]\n  bind @browser\n    [#div text: \"Request for: {{url}} - {{user-agent}}\"]\n```\n\n\n```\n  search @server\n    r = [#request url: \"/slack-message\" body: [text user_name]]\n  bind @browser\n    [#div text: \"Body for slack message is {{user_name}}: \\\"{{text}}\\\"\"]\n  commit @http\n    [#request from: r,\n      headers: [meep: \"moop\", beep: \"boop\"]\n      method: \"POST\"\n      url: \"https://hooks.slack.com/services/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\"\n      json: [text: \"{{user_name}} said: `{{text}}`\", icon_emoji: \":wizard:\", username: \"meep\"]]\n```\n","test.eve":"add a foo\n~~~\n  commit\n    [#foo value: \"hi!\"]\n~~~\n\nis test\n~~~\n  search\n    [#foo value]\n    result = if value = \"yo\" then \"cool\"\n              else if x = \"meh\" then x\n              else \"ok\"\n  commit\n    [#result result]\n~~~\n\n","tic-tac-toe.eve":"# Tic-Tac-Toe\n\n## Game logic\n\nTic-Tac-Toe is a classic game played by two players, \"X\" and \"O\", who take turns marking their letter on a 3x3 grid. The first player to mark 3 adjacent cells in a line wins. The game can potentially result in a draw, where all grid cells are marked, but neither player has 3 adjacent cells. To build this game in Eve, we need several parts:\n\n- A game board with cells\n- A way to mark a cell as \"X\" or \"O\"\n- A way to recognize that a player has won the game.\n\nTo begin, we initialize the board. We commit an object named `@board` to hold our global state and create a set of `#cell`s. These `#cell`s will keep track of the moves players have made. Common connect-N games (a generalized tic-tac-toe for any NxN grid) are scored along 4 axes (horizontal, vertical, the diagonal, and the anti-diagonal). We group cells together along each axis up front to make scoring easier later.\n\nThe game board is square, with a given `size`. It contains `size ^ 2 cells`,\neach with a row and column index.\n\n```\n  search\n    // board constants\n    size = 3\n    starting-player = \"X\"\n\n    // generate the cells\n    i = range[from: 1, to: size]\n    j = range[from: 1, to: size]\n\n commit\n    board = [#board size player: starting-player]\n    [#cell board row: i column: j]\n```\n\nA subtlety here is the last line, `[#cell board row: i column: j]`. Thanks to our relational semantics, this line actually generates all 9 cells. Since the sets of values computed in `i` and `j` have no relation to each other, when we use them together we get the [cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) of their values. This means that if `i = {0, 1, 2}` and `j = {0, 1, 2}`, then `i x j = {(1, 1), (1, 2), ... (3, 2), (3, 3)}`. These are exactly the indices we need for our grid!\n\nNow we tag some special cell groupings: diagonal and anti-diagonal cells. The diagonal cells are (1, 1), (2, 2), and (3, 3). From this we can see that diagonal cells have a row index equal to its column index\n\n```\n  search\n    cells = [#cell row column]\n    row = column\n\n  bind\n    cells += #diagonal\n```\n\nSimilarly, the anti-diagonal cells are (1, 3), (2, 2), and (3, 1).\n\nAnti-diagonal cells satisfy the equation `row + col = N + 1`,\nwhere N is the size of the board.\n\n```\n  search\n    cells = [#cell row column]\n    [#board size: N]\n    row + column = N + 1\n\n  bind\n    cells += #anti-diagonal\n```\n\nA game is won when a player marks N cells in a row, column, or diagonal.\nThe game can end in a tie, where no player has N in a row.\n\n```\n  search\n    board = [#board size: N, not(winner)]\n                     // Check for a winning row\n    (winner, cell) = if cell = [#cell row player]\n                       N = count[given: cell, per: (row, player)] then (player, cell)\n                     // Check for a winning column\n                     else if cell = [#cell column player]\n                       N = count[given: cell, per: (column, player)] then (player, cell)\n                     // Check for a diagonal win\n                     else if cell = [#diagonal row column player]\n                       N = count[given: cell, per: player] then (player, cell)\n                     // Check for an anti-diagonal win\n                     else if cell = [#anti-diagonal row column player]\n                       N = count[given: cell, per: player] then (player, cell)\n                     // If all cells are filled but there are no winners\n                     else if cell = [#cell player]\n                       N * N = count[given: cell] then (\"nobody\", cell)\n\n  commit\n    board.winner := winner\n    cell += #winner\n```\n\nWe use the `count` aggregate in the above block. Count returns the number of discrete values (the cardinality) of the variables in `given`. The optional `per` attribute allows you to specify groupings, which yield one result for each set of values in the group.\n\nFor example, in `count[given: cell, per: player]` we group by `player`, which returns two values: the count of cells marked by player `X` and those marked by `O`. This can be read \"count the cells per player\". In the scoring block, we group by `column` and `player`. This will return the count of cells marked by a player in a particular column. Like wise with the row case. By equating this with N, we ensure the winning player is only returned when she has marked N cells in the given direction.\n\nThis is how Eve works without looping. Rather than writing a nested `for` loop and iterating over the cells, we can use Eve's semantics to our advantage.\n\nWe first search every row, then every column. Finally we check the diagonal and anti-diagonal. To do this, we leverage the `#diagonal` and `#anti-diagonal` tags we created earlier; instead of selecting `[#cell]`, we can select on `[#diagonal]` and `[#anti-diagonal]` to select only a subset of cells.\n\n### React to Events\n\nNext, we handle user input. Any time a cell is directly clicked, we:\n\n1. Ensure the cell hasn't already been played\n2. Check for a winner\n3. Switch to the next player\n\nThen update the cell to reflect its new owner, and switch board's `player` to the next player.\n\nClick on a cell to make your move\n\n```\n  search @event @session @browser\n    [#click #direct-target element: [#div cell]]\n    not(cell.player)                               // Ensures the cell hasn't been played\n    board = [#board player: current, not(winner)]  // Ensures the game has not been won\n    next_player = if current = \"X\" then \"O\"        // Switches to the next player\n                  else \"X\"\n\n  commit\n    board.player := next_player\n    cell.player := current\n```\n\nSince games of tic-tac-toe are often very short and extremely competitive, it's imperative that it be quick and easy to begin a new match. When the game is over (the board has a `winner` attribute), a click anywhere on the drawing area will reset the game for another round of play.\n\nA reset consists of:\n- Clearing the board of a `winner`\n- Clearing all of the cells\n- Removing the `#winner` tag from the winning cell set\n\n```\n  search @event @browser @session\n    [#click element: [#div board]]\n    board = [#board winner]\n    cell = [#cell player]\n\n  commit\n    board.winner -= winner\n    cell.player -= player\n    cell -= #winner\n```\n\n## Drawing the Game Board\n\nWe've implemented the game logic, but now we need to actually draw the board so players have something to see and interact with. Our general strategy will be that the game board is a `#div` with one child `#div` for each cell. Each cell will be drawn with an \"X\", \"O\", or empty string as text. We also add a `#status` div, which we'll write game state into later. Our cells have the CSS inlined, but you could just as easily link to an external file.\n\nDraw the board\n\n```\n  search\n    board = [#board]\n    cell = [#cell board row column]\n    contents = if cell.player then cell.player\n              else \"\"\n\n  bind @browser\n    [#div board #container style: [font-family: \"sans-serif\"], children:\n      [#div #status board class: \"status\", style: [text-align: \"center\" width: 150 height: 50 padding-bottom: 10]]\n      [#div class: \"board\" style: [color: \"black\"] children:\n        [#div class: \"row\" sort: row children:\n          [#div #cell class: \"cell\" cell text: contents sort: column style:\n            [display: \"inline-block\" width: 50 height: 50 border: \"1px solid black\" background: \"white\" font-size: \"2em\" line-height: \"50px\" text-align: \"center\" vertical-align: \"top\"]]]]]\n```\n\nWinning cells are drawn in a different color\n\n```\n  search @session @browser\n    winning-cells = [#cell #winner]\n    cell-elements = [#div cell: winning-cells style]\n\n  bind @browser\n    style.color := \"blue\"\n```\n\nFinally, we fill the previously mentioned `#status` div with our current game state. If no winner has been declared, we remind the competitors of whose turn it is, and once a winner is found we announce her newly-acquired bragging rights.\n\nDisplay the current player if the game isn't won\n\n```\n  search @session @browser\n    status = [#status board]\n    not(board.winner)\n\n  bind @browser\n    status.text += \"It's {{board.player}}'s turn!\"\n```\n\nWhen the game is won, display the winner\n\n```\n  search @session @browser\n    status = [#status board]\n    winner = board.winner\n\n  bind @browser\n    status.text += \"{{winner}} wins! Click anywhere to restart!\"\n```\n","todomvc.eve":"# TodoMVC\n\n[TodoMVC][1] is a specification for a todo list web application. Its original purpose was to help developers evaluate the plethora of Javascript frameworks implementing the Model-View-Controller (MVC) design pattern. Today, it has evolved into a benchmark for programming languages and frameworks targeting the web, so TodoMVC apps donâ€™t necessarily reflect the MVC design pattern.\nTodoMVC is a great example to demonstrate Eve's capabilities, as our semantics naturally enable a concise implementation; without optimizing for line count, the program you're reading only contains 63 lines of Eve code.\n\n## Todos\n\nEach todo is tagged `#todo` and has a `body`, which is the text of the todo entered by the user. Additionally, each todo has two flags. The first flag is the `completed` flag affects how the todo is displayed, and allows the user to filter todos based on completed status; we can look at \"completed\" todos, \"active\" todos, or \"all\" todos. The second flag is the `editing` flag, used to toggle an editing mode on the todo. This is used later to allow the user to update the body text of the todo.\n\nThese todos exist in the context of an `#app`, which we use to hold global state information. We use it to place a filter on the todos. The filter can be one of \"completed\", \"active\", or \"all\".\n\n### The Application View\n\nWe draw Todo MVC here. All styling is handled in a separate CSS file. The app consists of three parts:\n\n1. __Header__ - Contains the `#toggle-all` button as well as `#new-todo`, which is an input box for entering new todos.\n2. __Body__ - Contains `#todo-list`, the list of todos. The work here is handled in the second block.\n3. __Footer__ - Contains the count of todos, as well as control buttons for filtering, and clearing completed todos.\n\nIn this block, we do a little work to determine todo-count, all-checked, and none-checked. Other than that, this block simply lays out the major control elements of TodoMVC. A key aspect of this block is the `bind` keyword. This denotes the beginning of the action phase of the block, and tells Eve that to update records as data changes. This is the key component that enables Eve to react to user interaction and update the display.\n\n```\nsearch\n  [#app filter]\n\n  all-checked = if not([#todo completed: false]) then true\n                else false\n\n  none-checked = if [#todo completed: true] then false\n                  else true\n\n  todo-count = if c = count[given: [#todo completed: false]] then c\n                else 0\n\nbind @browser\n    // Links to an external stylesheet\n  [#link rel: \"stylesheet\" href: \"examples/css/todomvc.css\"]\n  [#div class: \"todoapp\" children:\n\n    [#header children:\n        [#h1 text: \"todos\"]\n        [#input #new-todo, class: \"new-todo\", autofocus: true,\n                                         placeholder: \"What needs to be done?\"]\n        [#input #toggle-all class: \"toggle-all\", type: \"checkbox\",\n                                          checked: all-checked]]\n\n    [#div class: \"main\" children:\n        [#ul #todo-list, class: \"todo-list\"]]\n\n    [#footer children:\n        [#span #todo-count, class: \"todo-count\", children:\n            [#strong text: todo-count]\n        [#span text: \" items left\"]]\n        [#ul #filters, class: \"filters\", children:\n        [#li children: [#a href: \"#/examples/todomvc.eve/#/all\" text: \"all\"\n                                             class: [selected: is(filter = \"all\")]]]\n        [#li children: [#a href: \"#/examples/todomvc.eve/#/active\" text: \"active\"\n                                             class: [selected: is(filter = \"active\")]]]\n        [#li children: [#a href: \"#/examples/todomvc.eve/#/completed\" text: \"completed\"\n                                             class: [selected: is(filter = \"completed\")]]]]\n            [#span #clear-completed text: \"Clear completed\"\n                                                        class: [clear-completed: true,\n                                                hidden: none-checked]]]]\n```\n\n### Drawing the Todo List\n\nNow we look at how the todos are actually displayed in the application. We attach it to `#todo-list` using its `children` attribute. Each todo display element consists of:\n\n- a **list item**, with a checkbox for toggling the completed status of the todo\n- a **label** displaying the text of the todo\n- an **input textbox** for editing the text of the todo\n- a **button** for deleting the todo\n\n```\nsearch @session @browser\n  [#app filter]\n  parent = [#todo-list]\n\n  (todo, body, completed, editing) =\n    if filter = \"completed\"\n        then ([#todo, body, completed: true, editing], body, true, editing)\n\n    else if filter = \"active\"\n        then ([#todo, body, completed: false, editing], body, false, editing)\n\n    else if filter = \"all\"\n        then ([#todo, body, completed, editing], body, completed, editing)\n\nbind @browser\n  parent.children +=\n    [#li, class: [todo: true, completed, editing], todo, children:\n            [#input #todo-checkbox todo type: \"checkbox\" checked: completed\n                                                 class: [toggle: true, hidden: editing]]\n            [#label #todo-item, class: [hidden: editing], todo, text: body]\n            [#input #todo-editor, todo, value: body, autofocus: true\n                                                class: [edit: true,\n                                            hidden: toggle[value: editing]]]\n            [#button #remove-todo, class: [destroy: true, hidden: editing], todo]]\n```\n\nThanks to Eve's set semantics, we don't need any loops here; for every unique `#todo` in the database, Eve will do the work of adding another `#li` as a child of `#todo-list`.\n\n## Responding to User Events\n\n### Creating a New Todo\n\nA user can interact with TodoMVC in several ways. First and foremost, the user can create new todos. When the `@new-todo` input box is focused and the user presses enter, the value of the input is captured and a new todo is created.\n\n```\nsearch @event @session @browser\n  element = [#new-todo value]\n  kd = [#keydown element, key: \"enter\"]\n\ncommit\n  [#todo body: value, editing: false, completed: false, kd]\n\ncommit @browser\n  element.value := \"\"\n```\n\nOf note here is the record `[#todo body: value, editing: false, completed: false, kd]`. The inclusion of the `kd` attribute might seem strange, but its purpose is to guarantee the uniqueness of the todo. Letâ€™s say we want to add two todos with the same body. If `kd` were not an attribute, then the two todos would be exactly the same and Eveâ€™s set semantics would collapse them into a single todo. Therefore, we need some way to distinguish todos with identical bodies. Adding `kd` allows for this.\n\n### Editing Todos\n\nHere we handle all the ways we edit a todo. Editing includes changing the body as well as toggling the status of between complete and active.\n\n- click `#todo-checkbox` - toggles the completed status of the checkbox.\n- click `#toggle-all` - marks all todos as complete or incomplete, depending on the initial value. If all todos are marked incomplete, clicking `#toggle-all` will mark them complete. If only some are marked complete, then clicking `#toggle-all` will mark the rest complete. If all todos are marked as complete, then clicking `#toggle-all` will mark them all as incomplete.\n- blur `#todo-editor` - blurring the `#todo-editor` will cancel the edit\n- escape `#todo-editor` - this has the same effect as blurring\n- enter `#todo-editor` - commits the new text in `#todo-editor`, replacing the original body\n\n```\nsearch @event @session @browser\n\n  (todo, body, editing, completed) =\n\n    if [#click element: [#todo-checkbox todo]]\n        then (todo, todo.body, todo.editing, toggle[value: todo.completed])\n\n    else if [#click element: [#toggle-all checked]]\n        then ([#todo body], body, todo.editing, toggle[value: checked])\n\n    else if [#double-click element: [#todo-item todo]]\n        then (todo, todo.body, true, todo.completed)\n\n    else if [#blur element: [#todo-editor todo value]]\n        then (todo, value, false, todo.completed)\n\n    else if [#keydown element: [#todo-editor todo] key: \"escape\"]\n        then (todo, todo.body, false, todo.completed)\n\n    else if [#keydown element: [#todo-editor todo value] key: \"enter\"]\n        then (todo, value, false, todo.completed)\n\ncommit\n  todo <- [body, completed, editing]\n```\n\n### Deleting Todos\n\nWe remove a todo from the list by setting the todo's record to special `none` value. Doing so completely erases that todo from the database.\n\n```\nsearch @event @session @browser\n  todo =\n    if [#click element: [#remove-todo todo]]\n            then todo\n\n        else if [#click element: [#clear-completed]]\n            then [#todo completed: true]\n\ncommit\n  todo := none\n```\n\n### Filtering Todos (Routing)\n\nThe TodoMVC specification requires filtering via the URL. This is actually how the filter buttons work; if you look at their href attributes, they modify the URL with certain tags:\n\n- all - displays all todos\n- active - displays active todos only\n- completed - displays completed todos only\n\nWe can extract this value using `#url`, which has a hash-segment attribute that automatically parses the URL for us, returning the `value` (expected to be any one of the above). Any other value will fail to show any todos, but the application will not break.\n\n```\nsearch @browser\n  value = if [#url hash-segment: [index: 1, value]]\n                    then value\n          else \"all\"\nbind\n  [#app filter: value]\n```\n\n[1]: http://todomvc.com/\n","view.eve":"# Views\n\n## Simple\n\n### Value\n\nA `#value` view just embeds the `value`(s) its passed. If those values happen to be entities, we'll tag them as such for composite views to mess with.\n\n```\nsearch @view\n  wrapper = [#value value]\n  ix = sort[value]\n  lookup[record: wrapper, attribute: \"tag\", value: \"value\", node]\n\n  is-entity = if substring[text: value to: 1] = \"â¦‘\" then true\n              else false\n\nbind @browser\n  wrapper <- [#view #div node class: \"view\" children:\n    [#div #value sort: ix text: value is-entity]]\n```\n\n## Tables\n\n### Table\n\nA `#table` is a simple N-column N-row grid.\n\nCreate the wrapper for the table.\n@NOTE: This needs to sort.\n\n```\nsearch @view\n  wrapper = [#table field row]\n  lookup[record: wrapper, attribute: \"tag\", value: \"table\", node]\n  lookup[record: row attribute: field value]\n\nbind @browser @view\n  wrapper <- [#view #table node class: \"view\" children:\n    [#thead wrapper sort: 0 children:\n      [#tr children:\n        [#td text: field]]]\n    [#tr row children:\n      [#td field text: value]]]\n```\n\n### KV Table\n\nA `#kv-table` is a two-column table which may have many values per key. All values for the same key will be grouped.\n\nCreate the DOM structure for `#kv-table`s.\n\n```\nsearch @view\n  wrapper = [#kv-table kvs: [key]]\n  ix = sort[value: key]\n\nbind @browser\n  wrapper <- [#kv-table #view #div class: \"view kv-table\" children:\n    [#div #kv-row key class: \"kv-row\" sort: ix wrapper children:\n      [#div class: \"kv-key\" text: key]\n      [#div #kv-values class: \"kv-values\" wrapper key]]]\n```\n\nInject the values for each key in the `#kv-table`.\n\n```\nsearch @view\n  wrapper = [#kv-table kvs: [key value]]\n  ix = sort[value per: key]\n\nsearch @browser\n  value-column = [#kv-values wrapper key]\n\nbind @view @browser\n  value-column.children += [#value value-column value sort: ix]\n```\n\n### Attribute Table\n\n**DEPRECATED** This is a hack, since we do not support dynamic scoping, you cannot control what scope it finds EAVs in. Do not use this.\n\n```\nsearch @view\n  wrapper = [#attribute-table entity]\n  lookup[record: wrapper, attribute: \"tag\", value: \"attribute-table\", node]\n\nsearch (@session, @browser)\n  lookup[record: entity attribute: key value]\n\nbind @view @browser\n  wrapper.node := node\n  wrapper.tag += \"kv-table\"\n  wrapper.kvs := [key value]\n```\n\n\n## Charts & Graphs\n\n### Bar Graph\n\nSince we don't have min/max yet, we calculate it separately with sort.\n\n```\nsearch @view\n  wrapper = [#bar-graph bar: [height]]\n  sort[value: height, direction: \"down\", per: wrapper] = 1\n\nbind @view\n  wrapper.max-height := height\n```\n\n```\nsearch @view\n  wrapper = [#bar-graph bar max-height]\n  node = if wrapper.node then wrapper.node\n         else if lookup[record: wrapper, attribute: \"tag\", value: \"bar-graph\", node] then node\n\n  graph-height = if wrapper.height then wrapper.height\n                 else 300\n\n  graph-width = if wrapper.width then wrapper.width\n                 else 500\n\n  bar = [label height]\n\n  text = if bar = [#unlabeled] then \"\"\n         else label\n\n  sort = if bar.sort then bar.sort\n         else bar\n  bar-count = count[given: bar, per: wrapper]\n\n  bar-width = if bar.width then bar.width\n              else graph-width / bar-count\n\n  bar-height = if max-height = 0 then 0\n               else (height / max-height) * (graph-height - 30) // padding!\n\nbind @browser\n  wrapper <- [#view #div node class: \"view bar-graph\" style: [width: graph-width, height: graph-height] children:\n    [#div wrapper class: \"bar-graph-bar\" label | sort style: [width: bar-width height: bar-height] text]]\n```\n\n### history\n\nCommit the values so they stick around\n\n~~~\nsearch @view @stored\n  history = [#history values]\n  not(values = [#stored])\n  values = [value]\n  ix = if history.ix then history.ix + 1\n       else 1\n\ncommit @stored\n  history.values += values\n  values.ix := ix\n  values += #stored\n  history.ix := ix\n~~~\n\n~~~\nsearch @view\n  history = [#history values]\n  values = [value]\n\ncommit @stored\n  values.value := value\n~~~\n\nRemove values as the history size grows\n\n~~~\nsearch @view @stored\n  history = [#history values]\n  size = if history.history-size then history.history-size\n         else 30\n  not(not(values.ix))\n  total = count[given: values]\n  total > size\n  lowest = min[value: values.ix, given: values]\n  [#history values: values2]\n  values2 = [ix: lowest]\n\ncommit @stored\n  values2 := none\n~~~\n\nHistory views are just special bar-graphs\n\n~~~\nsearch @view @stored\n  history = [#history values]\n  lookup[record: history, attribute: \"tag\", value: \"history\", node]\nsearch @stored\n  values.value\nbind @view\n  [#bar-graph history node | bar: [#unlabeled label: values.ix, sort: values.ix, height: values.value width: 15]]\n~~~\n"}